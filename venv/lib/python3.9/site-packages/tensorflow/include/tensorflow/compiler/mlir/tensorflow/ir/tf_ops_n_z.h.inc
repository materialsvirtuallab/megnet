/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Declarations                                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#if defined(GET_OP_CLASSES) || defined(GET_OP_FWD_DEFINES)
#undef GET_OP_FWD_DEFINES
namespace mlir {
namespace TF {
class NdtriOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class NegOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class NextAfterOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class NoOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class NonMaxSuppressionV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class NonMaxSuppressionV4Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class NonMaxSuppressionV5Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class NotEqualOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OneHotOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OneShotIteratorOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OnesLikeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OptimizeDatasetV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OptionalFromValueOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OptionalGetValueOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OptionalHasValueOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OptionalNoneOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class OutfeedEnqueueTupleOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PackOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PadOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PadV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ParallelDynamicStitchOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ParallelMapDatasetOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ParallelMapDatasetV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ParameterizedTruncatedNormalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ParseExampleOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ParseExampleV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PartitionedCallOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PlaceholderOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PlaceholderWithDefaultOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PolygammaOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PopulationCountOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PowOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PrefetchDatasetOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PreventGradientOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PrintOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class PrintV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ProdOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class QrOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class QuantizeAndDequantizeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class QuantizeAndDequantizeV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class QuantizeAndDequantizeV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class QuantizeAndDequantizeV4Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class QueueDequeueV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RFFT2DOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RFFT3DOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RFFTOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RGBToHSVOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RaggedGatherOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RaggedRangeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomGammaGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomGammaOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomPoissonOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomPoissonV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomShuffleOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomStandardNormalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomUniformIntOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RandomUniformOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RangeDatasetOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RangeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RankOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReadVariableOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RealDivOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RealOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReciprocalGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReciprocalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RecvOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RecvTPUEmbeddingActivationsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReduceDatasetOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReduceJoinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class Relu6GradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class Relu6Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReluGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReluOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RemoteCallOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RepeatDatasetOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReshapeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResizeBilinearGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResizeBilinearOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResizeNearestNeighborGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResizeNearestNeighborOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyAdaMaxOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyAdadeltaOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyAdagradDAOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyAdagradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyAdagradV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyAdamOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyAddSignOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyCenteredRMSPropOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyFtrlOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyFtrlV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyGradientDescentOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyKerasMomentumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyMomentumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyPowerSignOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyProximalAdagradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyProximalGradientDescentOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceApplyRMSPropOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceGatherOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterAddOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterDivOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterMaxOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterMinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterMulOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterNdAddOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterNdSubOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterNdUpdateOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterSubOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceScatterUpdateOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ResourceStridedSliceAssignOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RestoreOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RestoreV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingADAMParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingAdadeltaParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingAdagradParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingCenteredRMSPropParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingFTRLParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingMDLAdagradLightParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingMomentumParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingProximalAdagradParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingProximalYogiParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingRMSPropParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RetrieveTPUEmbeddingStochasticGradientDescentParametersOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReverseOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReverseSequenceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ReverseV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RightShiftOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RintOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RiscAddOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RiscDotOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RngReadAndSkipOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RollOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RoundOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RsqrtGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class RsqrtOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SaveOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SaveSlicesOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SaveV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ScatterNdOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SegmentMaxOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SegmentMeanOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SegmentMinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SegmentProdOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SegmentSumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SelectOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SelectV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SelfAdjointEigV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SeluGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SeluOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SendOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SendTPUEmbeddingGradientsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SerializeIteratorOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SerializeSparseOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShapeNOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShapeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShardedFilenameOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShuffleAndRepeatDatasetV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShuffleDatasetV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShuffleDatasetV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShutdownDistributedTPUOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ShutdownTPUSystemOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SigmoidGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SigmoidOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SignOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SinhOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SizeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SliceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SnapshotOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SoftmaxCrossEntropyWithLogitsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SoftmaxOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SoftplusGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SoftplusOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SoftsignGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SoftsignOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SpaceToBatchNDOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SpaceToBatchOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SpaceToDepthOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseAddOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseFillEmptyRowsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseMatMulOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseReduceSumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseReshapeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSegmentMeanGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSegmentMeanOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSegmentMeanWithNumSegmentsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSegmentSqrtNGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSegmentSqrtNOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSegmentSqrtNWithNumSegmentsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSegmentSumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseSoftmaxCrossEntropyWithLogitsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SparseToDenseOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SplitOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SplitVOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SqrtGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SqrtOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SquareOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SquaredDifferenceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SqueezeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StackCloseV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StackPopV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StackPushV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StackV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatefulPartitionedCallOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatefulStandardNormalV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatefulTruncatedNormalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatefulUniformFullIntOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatefulUniformIntOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatefulUniformOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessMultinomialOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessParameterizedTruncatedNormalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomBinomialOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomGammaV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomGetAlgOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomGetKeyCounterAlgOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomGetKeyCounterOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomNormalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomNormalV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomPoissonOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomUniformFullIntOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomUniformFullIntV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomUniformIntOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomUniformIntV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomUniformOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessRandomUniformV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessTruncatedNormalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StatelessTruncatedNormalV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StaticRegexFullMatchOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StopGradientOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StridedSliceGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StridedSliceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StringFormatOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StringJoinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StringStripOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class StringToHashBucketFastOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SubOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SummaryWriterOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SvdOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class SymbolicGradientOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUCompilationResultOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUCompileMlirAndExecuteOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUCompileSucceededAssertOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUCopyWithLayoutOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUEmbeddingActivationsOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUExecuteAndUpdateVariablesOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUExecuteOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUGetLayoutOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUOrdinalSelectorOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUPartitionedCallOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUPartitionedInputOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUPartitionedOutputOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUReplicateMetadataOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUReplicatedInputOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUReplicatedOutputOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPUReshardVariablesOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TPURoundRobinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TakeDatasetOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TanOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TanhGradOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TanhOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayCloseV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayConcatV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayGatherV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayGradV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayReadV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayScatterV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArraySizeV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArraySplitV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorArrayWriteV3Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListConcatV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListElementShapeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListFromTensorOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListGatherOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListGetItemOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListLengthOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListPopBackOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListPushBackOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListReserveOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListResizeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListScatterIntoExistingListOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListSetItemOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorListStackOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorScatterAddOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorScatterMaxOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorScatterMinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorScatterSubOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorScatterUpdateOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorSliceDatasetOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TensorStridedSliceUpdateOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TileOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TimestampOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ToBoolOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TopKUniqueOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TopKV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TopKWithUniqueOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TransposeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TridiagonalSolveOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TruncateDivOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TruncateModOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class TruncatedNormalOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UncompressElementOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UniqueOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UnpackOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UnsortedSegmentMaxOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UnsortedSegmentMinOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UnsortedSegmentProdOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UnsortedSegmentSumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class UpperBoundOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class VarHandleOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class VarIsInitializedOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class VariableOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class VariableShapeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class VariableV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WhereOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WhileOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WhileRegionOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WriteAudioSummaryOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WriteGraphSummaryOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WriteHistogramSummaryOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WriteImageSummaryOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WriteRawProtoSummaryOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WriteScalarSummaryOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class WriteSummaryOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XdivyOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaAllReduceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaBroadcastHelperOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaClusterOutputOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaConvOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaConvV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaDotOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaDotV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaDynamicSliceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaDynamicUpdateSliceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaEinsumOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaGatherOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaHostComputeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaKeyValueSortOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaPadOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaRecvFromHostOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaReduceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaReduceScatterOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaReduceWindowOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaRemoveDynamicDimensionSizeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaReplicaIdOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaRngBitGeneratorOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaScatterOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaSelectAndScatterOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaSelfAdjointEigOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaSendToHostOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaSetDynamicDimensionSizeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaShardingOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaSortOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaSvdOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaVariadicReduceOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaVariadicReduceV2Op;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlaVariadicSortOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class Xlog1pyOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class XlogyOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class YieldOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ZerosLikeOp;
} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {
class ZetaOp;
} // namespace TF
} // namespace mlir
#endif

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NdtriOp declarations
//===----------------------------------------------------------------------===//

class NdtriOpAdaptor {
public:
  NdtriOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NdtriOpAdaptor(NdtriOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NdtriOp : public ::mlir::Op<NdtriOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NdtriOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Ndtri");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NdtriOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NegOp declarations
//===----------------------------------------------------------------------===//

class NegOpAdaptor {
public:
  NegOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NegOpAdaptor(NegOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NegOp : public ::mlir::Op<NegOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsInvolution, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::OpTrait::TF::CwiseUnary, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NegOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Neg");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NegOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NextAfterOp declarations
//===----------------------------------------------------------------------===//

class NextAfterOpAdaptor {
public:
  NextAfterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NextAfterOpAdaptor(NextAfterOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x1();
  ::mlir::Value x2();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NextAfterOp : public ::mlir::Op<NextAfterOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NextAfterOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.NextAfter");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x1();
  ::mlir::Value x2();
  ::mlir::MutableOperandRange x1Mutable();
  ::mlir::MutableOperandRange x2Mutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value x1, ::mlir::Value x2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x1, ::mlir::Value x2);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NextAfterOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NoOp declarations
//===----------------------------------------------------------------------===//

class NoOpAdaptor {
public:
  NoOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NoOpAdaptor(NoOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NoOp : public ::mlir::Op<NoOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NoOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.NoOp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NoOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NonMaxSuppressionV3Op declarations
//===----------------------------------------------------------------------===//

class NonMaxSuppressionV3OpAdaptor {
public:
  NonMaxSuppressionV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NonMaxSuppressionV3OpAdaptor(NonMaxSuppressionV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value boxes();
  ::mlir::Value scores();
  ::mlir::Value max_output_size();
  ::mlir::Value iou_threshold();
  ::mlir::Value score_threshold();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NonMaxSuppressionV3Op : public ::mlir::Op<NonMaxSuppressionV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NonMaxSuppressionV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("T_threshold")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier T_thresholdAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier T_thresholdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.NonMaxSuppressionV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value boxes();
  ::mlir::Value scores();
  ::mlir::Value max_output_size();
  ::mlir::Value iou_threshold();
  ::mlir::Value score_threshold();
  ::mlir::MutableOperandRange boxesMutable();
  ::mlir::MutableOperandRange scoresMutable();
  ::mlir::MutableOperandRange max_output_sizeMutable();
  ::mlir::MutableOperandRange iou_thresholdMutable();
  ::mlir::MutableOperandRange score_thresholdMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value selected_indices();
  ::mlir::Type T();
  ::mlir::Type T_threshold();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NonMaxSuppressionV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NonMaxSuppressionV4Op declarations
//===----------------------------------------------------------------------===//

class NonMaxSuppressionV4OpAdaptor {
public:
  NonMaxSuppressionV4OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NonMaxSuppressionV4OpAdaptor(NonMaxSuppressionV4Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value boxes();
  ::mlir::Value scores();
  ::mlir::Value max_output_size();
  ::mlir::Value iou_threshold();
  ::mlir::Value score_threshold();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr pad_to_max_output_size();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NonMaxSuppressionV4Op : public ::mlir::Op<NonMaxSuppressionV4Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NonMaxSuppressionV4OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("pad_to_max_output_size"), ::llvm::StringRef("T"), ::llvm::StringRef("T_threshold")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier pad_to_max_output_sizeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier pad_to_max_output_sizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier T_thresholdAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier T_thresholdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.NonMaxSuppressionV4");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value boxes();
  ::mlir::Value scores();
  ::mlir::Value max_output_size();
  ::mlir::Value iou_threshold();
  ::mlir::Value score_threshold();
  ::mlir::MutableOperandRange boxesMutable();
  ::mlir::MutableOperandRange scoresMutable();
  ::mlir::MutableOperandRange max_output_sizeMutable();
  ::mlir::MutableOperandRange iou_thresholdMutable();
  ::mlir::MutableOperandRange score_thresholdMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value selected_indices();
  ::mlir::Value valid_outputs();
  ::mlir::BoolAttr pad_to_max_output_sizeAttr();
  bool pad_to_max_output_size();
  ::mlir::Type T();
  ::mlir::Type T_threshold();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void pad_to_max_output_sizeAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::BoolAttr pad_to_max_output_size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::BoolAttr pad_to_max_output_size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, bool pad_to_max_output_size = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, bool pad_to_max_output_size = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NonMaxSuppressionV4Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NonMaxSuppressionV5Op declarations
//===----------------------------------------------------------------------===//

class NonMaxSuppressionV5OpAdaptor {
public:
  NonMaxSuppressionV5OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NonMaxSuppressionV5OpAdaptor(NonMaxSuppressionV5Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value boxes();
  ::mlir::Value scores();
  ::mlir::Value max_output_size();
  ::mlir::Value iou_threshold();
  ::mlir::Value score_threshold();
  ::mlir::Value soft_nms_sigma();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr pad_to_max_output_size();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NonMaxSuppressionV5Op : public ::mlir::Op<NonMaxSuppressionV5Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<6>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NonMaxSuppressionV5OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("pad_to_max_output_size"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier pad_to_max_output_sizeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier pad_to_max_output_sizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.NonMaxSuppressionV5");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value boxes();
  ::mlir::Value scores();
  ::mlir::Value max_output_size();
  ::mlir::Value iou_threshold();
  ::mlir::Value score_threshold();
  ::mlir::Value soft_nms_sigma();
  ::mlir::MutableOperandRange boxesMutable();
  ::mlir::MutableOperandRange scoresMutable();
  ::mlir::MutableOperandRange max_output_sizeMutable();
  ::mlir::MutableOperandRange iou_thresholdMutable();
  ::mlir::MutableOperandRange score_thresholdMutable();
  ::mlir::MutableOperandRange soft_nms_sigmaMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value selected_indices();
  ::mlir::Value selected_scores();
  ::mlir::Value valid_outputs();
  ::mlir::BoolAttr pad_to_max_output_sizeAttr();
  bool pad_to_max_output_size();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void pad_to_max_output_sizeAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type selected_scores, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, ::mlir::BoolAttr pad_to_max_output_size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, ::mlir::BoolAttr pad_to_max_output_size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type selected_scores, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, bool pad_to_max_output_size = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, bool pad_to_max_output_size = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NonMaxSuppressionV5Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NotEqualOp declarations
//===----------------------------------------------------------------------===//

class NotEqualOpAdaptor {
public:
  NotEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  NotEqualOpAdaptor(NotEqualOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr incompatible_shape_error();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class NotEqualOp : public ::mlir::Op<NotEqualOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::IsCommutative, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NotEqualOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("incompatible_shape_error"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier incompatible_shape_errorAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier incompatible_shape_errorAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.NotEqual");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::BoolAttr incompatible_shape_errorAttr();
  bool incompatible_shape_error();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void incompatible_shape_errorAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y, BoolAttr incompatible_shape_error);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr incompatible_shape_error);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr incompatible_shape_error);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, bool incompatible_shape_error = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, bool incompatible_shape_error = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::NotEqualOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OneHotOp declarations
//===----------------------------------------------------------------------===//

class OneHotOpAdaptor {
public:
  OneHotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OneHotOpAdaptor(OneHotOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value indices();
  ::mlir::Value depth();
  ::mlir::Value on_value();
  ::mlir::Value off_value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr axis();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OneHotOp : public ::mlir::Op<OneHotOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OneHotOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("axis"), ::llvm::StringRef("T"), ::llvm::StringRef("TI")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier axisAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier axisAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TIAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TIAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OneHot");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value indices();
  ::mlir::Value depth();
  ::mlir::Value on_value();
  ::mlir::Value off_value();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange depthMutable();
  ::mlir::MutableOperandRange on_valueMutable();
  ::mlir::MutableOperandRange off_valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr axisAttr();
  uint64_t axis();
  ::mlir::Type T();
  ::mlir::Type TI();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void axisAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value indices, Value depth, Value on_value, Value off_value, IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OneHotOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OneShotIteratorOp declarations
//===----------------------------------------------------------------------===//

class OneShotIteratorOpAdaptor {
public:
  OneShotIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OneShotIteratorOpAdaptor(OneShotIteratorOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr dataset_factory();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::StringAttr container();
  ::mlir::StringAttr shared_name();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OneShotIteratorOp : public ::mlir::Op<OneShotIteratorOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OneShotIteratorOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataset_factory"), ::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes"), ::llvm::StringRef("container"), ::llvm::StringRef("shared_name")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dataset_factoryAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dataset_factoryAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier containerAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier containerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier shared_nameAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier shared_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OneShotIterator");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::SymbolRefAttr dataset_factoryAttr();
  ::mlir::SymbolRefAttr dataset_factory();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::StringAttr containerAttr();
  ::llvm::StringRef container();
  ::mlir::StringAttr shared_nameAttr();
  ::llvm::StringRef shared_name();
  void dataset_factoryAttr(::mlir::SymbolRefAttr attr);
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  void containerAttr(::mlir::StringAttr attr);
  void shared_nameAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OneShotIteratorOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OnesLikeOp declarations
//===----------------------------------------------------------------------===//

class OnesLikeOpAdaptor {
public:
  OnesLikeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OnesLikeOpAdaptor(OnesLikeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OnesLikeOp : public ::mlir::Op<OnesLikeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsIdempotent, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OnesLikeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OnesLike");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OnesLikeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OptimizeDatasetV2Op declarations
//===----------------------------------------------------------------------===//

class OptimizeDatasetV2OpAdaptor {
public:
  OptimizeDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OptimizeDatasetV2OpAdaptor(OptimizeDatasetV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value optimizations_enabled();
  ::mlir::Value optimizations_disabled();
  ::mlir::Value optimizations_default();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::ArrayAttr optimization_configs();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OptimizeDatasetV2Op : public ::mlir::Op<OptimizeDatasetV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OptimizeDatasetV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes"), ::llvm::StringRef("optimization_configs")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier optimization_configsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier optimization_configsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OptimizeDatasetV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value optimizations_enabled();
  ::mlir::Value optimizations_disabled();
  ::mlir::Value optimizations_default();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange optimizations_enabledMutable();
  ::mlir::MutableOperandRange optimizations_disabledMutable();
  ::mlir::MutableOperandRange optimizations_defaultMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::ArrayAttr optimization_configsAttr();
  ::mlir::ArrayAttr optimization_configs();
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  void optimization_configsAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value optimizations_enabled, ::mlir::Value optimizations_disabled, ::mlir::Value optimizations_default, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::ArrayAttr optimization_configs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value optimizations_enabled, ::mlir::Value optimizations_disabled, ::mlir::Value optimizations_default, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::ArrayAttr optimization_configs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OptimizeDatasetV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OptionalFromValueOp declarations
//===----------------------------------------------------------------------===//

class OptionalFromValueOpAdaptor {
public:
  OptionalFromValueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OptionalFromValueOpAdaptor(OptionalFromValueOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange components();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OptionalFromValueOp : public ::mlir::Op<OptionalFromValueOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OptionalFromValueOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Toutput_types")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier Toutput_typesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier Toutput_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OptionalFromValue");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range components();
  ::mlir::MutableOperandRange componentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value optional();
  mlir::OperandElementTypeRange Toutput_types();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type optional, ::mlir::ValueRange components);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OptionalFromValueOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OptionalGetValueOp declarations
//===----------------------------------------------------------------------===//

class OptionalGetValueOpAdaptor {
public:
  OptionalGetValueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OptionalGetValueOpAdaptor(OptionalGetValueOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value optional();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OptionalGetValueOp : public ::mlir::Op<OptionalGetValueOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OptionalGetValueOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_shapes"), ::llvm::StringRef("output_types")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OptionalGetValue");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value optional();
  ::mlir::MutableOperandRange optionalMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range components();
  mlir::TF::ResultShapeRange output_shapes();
  mlir::ResultElementTypeRange output_types();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value optional);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OptionalGetValueOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OptionalHasValueOp declarations
//===----------------------------------------------------------------------===//

class OptionalHasValueOpAdaptor {
public:
  OptionalHasValueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OptionalHasValueOpAdaptor(OptionalHasValueOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value optional();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OptionalHasValueOp : public ::mlir::Op<OptionalHasValueOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OptionalHasValueOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OptionalHasValue");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value optional();
  ::mlir::MutableOperandRange optionalMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value has_value();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type has_value, ::mlir::Value optional);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value optional);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OptionalHasValueOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OptionalNoneOp declarations
//===----------------------------------------------------------------------===//

class OptionalNoneOpAdaptor {
public:
  OptionalNoneOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OptionalNoneOpAdaptor(OptionalNoneOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OptionalNoneOp : public ::mlir::Op<OptionalNoneOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OptionalNoneOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OptionalNone");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value optional();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type optional);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OptionalNoneOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OutfeedEnqueueTupleOp declarations
//===----------------------------------------------------------------------===//

class OutfeedEnqueueTupleOpAdaptor {
public:
  OutfeedEnqueueTupleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  OutfeedEnqueueTupleOpAdaptor(OutfeedEnqueueTupleOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class OutfeedEnqueueTupleOp : public ::mlir::Op<OutfeedEnqueueTupleOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OutfeedEnqueueTupleOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtypes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.OutfeedEnqueueTuple");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::MutableOperandRange inputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  mlir::OperandElementTypeRange dtypes();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::OutfeedEnqueueTupleOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PackOp declarations
//===----------------------------------------------------------------------===//

class PackOpAdaptor {
public:
  PackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PackOpAdaptor(PackOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange values();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr axis();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PackOp : public ::mlir::Op<PackOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PackOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("axis"), ::llvm::StringRef("N"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier axisAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier axisAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Pack");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range values();
  ::mlir::MutableOperandRange valuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr axisAttr();
  uint64_t axis();
  size_t N();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void axisAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange values, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange values, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange values, uint64_t axis = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange values, uint64_t axis = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PackOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PadOp declarations
//===----------------------------------------------------------------------===//

class PadOpAdaptor {
public:
  PadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PadOpAdaptor(PadOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value paddings();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PadOp : public ::mlir::Op<PadOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, FoldOperandsTransposeInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PadOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tpaddings")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TpaddingsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TpaddingsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Pad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value paddings();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange paddingsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tpaddings();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // TF_FoldOperandsTransposeInterface:
    SmallVector<unsigned, 4> GetLayoutDependentArgs() { return {0}; }
    SmallVector<unsigned, 4> GetLayoutDependentResults() { return {0}; }
    LogicalResult FoldOperandsPermutation(ArrayRef<int64_t> permutation);
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PadOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PadV2Op declarations
//===----------------------------------------------------------------------===//

class PadV2OpAdaptor {
public:
  PadV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PadV2OpAdaptor(PadV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value paddings();
  ::mlir::Value constant_values();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PadV2Op : public ::mlir::Op<PadV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PadV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tpaddings")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TpaddingsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TpaddingsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.PadV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value paddings();
  ::mlir::Value constant_values();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange paddingsMutable();
  ::mlir::MutableOperandRange constant_valuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tpaddings();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, ::mlir::Value constant_values);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, ::mlir::Value constant_values);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PadV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParallelDynamicStitchOp declarations
//===----------------------------------------------------------------------===//

class ParallelDynamicStitchOpAdaptor {
public:
  ParallelDynamicStitchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ParallelDynamicStitchOpAdaptor(ParallelDynamicStitchOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange indices();
  ::mlir::ValueRange data();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ParallelDynamicStitchOp : public ::mlir::Op<ParallelDynamicStitchOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParallelDynamicStitchOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("N"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ParallelDynamicStitch");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range indices();
  ::mlir::Operation::operand_range data();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange dataMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value merged();
  size_t N();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type merged, ::mlir::ValueRange indices, ::mlir::ValueRange data);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange indices, ::mlir::ValueRange data);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ParallelDynamicStitchOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParallelMapDatasetOp declarations
//===----------------------------------------------------------------------===//

class ParallelMapDatasetOpAdaptor {
public:
  ParallelMapDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ParallelMapDatasetOpAdaptor(ParallelMapDatasetOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::ValueRange other_arguments();
  ::mlir::Value num_parallel_calls();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr f();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr use_inter_op_parallelism();
  ::mlir::BoolAttr sloppy();
  ::mlir::BoolAttr preserve_cardinality();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ParallelMapDatasetOp : public ::mlir::Op<ParallelMapDatasetOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParallelMapDatasetOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes"), ::llvm::StringRef("use_inter_op_parallelism"), ::llvm::StringRef("sloppy"), ::llvm::StringRef("preserve_cardinality"), ::llvm::StringRef("Targuments")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier use_inter_op_parallelismAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier use_inter_op_parallelismAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier sloppyAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier sloppyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier preserve_cardinalityAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier preserve_cardinalityAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TargumentsAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TargumentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ParallelMapDataset");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Operation::operand_range other_arguments();
  ::mlir::Value num_parallel_calls();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange other_argumentsMutable();
  ::mlir::MutableOperandRange num_parallel_callsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::SymbolRefAttr fAttr();
  ::mlir::SymbolRefAttr f();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr use_inter_op_parallelismAttr();
  bool use_inter_op_parallelism();
  ::mlir::BoolAttr sloppyAttr();
  bool sloppy();
  ::mlir::BoolAttr preserve_cardinalityAttr();
  bool preserve_cardinality();
  mlir::OperandElementTypeRange Targuments();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void fAttr(::mlir::SymbolRefAttr attr);
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  void use_inter_op_parallelismAttr(::mlir::BoolAttr attr);
  void sloppyAttr(::mlir::BoolAttr attr);
  void preserve_cardinalityAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::BoolAttr sloppy, ::mlir::BoolAttr preserve_cardinality);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::BoolAttr sloppy, ::mlir::BoolAttr preserve_cardinality);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism = true, bool sloppy = false, bool preserve_cardinality = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism = true, bool sloppy = false, bool preserve_cardinality = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ParallelMapDatasetOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParallelMapDatasetV2Op declarations
//===----------------------------------------------------------------------===//

class ParallelMapDatasetV2OpAdaptor {
public:
  ParallelMapDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ParallelMapDatasetV2OpAdaptor(ParallelMapDatasetV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::ValueRange other_arguments();
  ::mlir::Value num_parallel_calls();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr f();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr use_inter_op_parallelism();
  ::mlir::StringAttr deterministic();
  ::mlir::BoolAttr preserve_cardinality();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ParallelMapDatasetV2Op : public ::mlir::Op<ParallelMapDatasetV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParallelMapDatasetV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes"), ::llvm::StringRef("use_inter_op_parallelism"), ::llvm::StringRef("deterministic"), ::llvm::StringRef("preserve_cardinality"), ::llvm::StringRef("Targuments")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier use_inter_op_parallelismAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier use_inter_op_parallelismAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier deterministicAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier deterministicAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier preserve_cardinalityAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier preserve_cardinalityAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TargumentsAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TargumentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ParallelMapDatasetV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Operation::operand_range other_arguments();
  ::mlir::Value num_parallel_calls();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange other_argumentsMutable();
  ::mlir::MutableOperandRange num_parallel_callsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::SymbolRefAttr fAttr();
  ::mlir::SymbolRefAttr f();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr use_inter_op_parallelismAttr();
  bool use_inter_op_parallelism();
  ::mlir::StringAttr deterministicAttr();
  ::llvm::StringRef deterministic();
  ::mlir::BoolAttr preserve_cardinalityAttr();
  bool preserve_cardinality();
  mlir::OperandElementTypeRange Targuments();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void fAttr(::mlir::SymbolRefAttr attr);
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  void use_inter_op_parallelismAttr(::mlir::BoolAttr attr);
  void deterministicAttr(::mlir::StringAttr attr);
  void preserve_cardinalityAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::StringAttr deterministic, ::mlir::BoolAttr preserve_cardinality);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::StringAttr deterministic, ::mlir::BoolAttr preserve_cardinality);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism = true, ::llvm::StringRef deterministic = "default", bool preserve_cardinality = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism = true, ::llvm::StringRef deterministic = "default", bool preserve_cardinality = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ParallelMapDatasetV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParameterizedTruncatedNormalOp declarations
//===----------------------------------------------------------------------===//

class ParameterizedTruncatedNormalOpAdaptor {
public:
  ParameterizedTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ParameterizedTruncatedNormalOpAdaptor(ParameterizedTruncatedNormalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value means();
  ::mlir::Value stdevs();
  ::mlir::Value minvals();
  ::mlir::Value maxvals();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ParameterizedTruncatedNormalOp : public ::mlir::Op<ParameterizedTruncatedNormalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParameterizedTruncatedNormalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("T"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ParameterizedTruncatedNormal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value means();
  ::mlir::Value stdevs();
  ::mlir::Value minvals();
  ::mlir::Value maxvals();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange meansMutable();
  ::mlir::MutableOperandRange stdevsMutable();
  ::mlir::MutableOperandRange minvalsMutable();
  ::mlir::MutableOperandRange maxvalsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type T();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ParameterizedTruncatedNormalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParseExampleOp declarations
//===----------------------------------------------------------------------===//

class ParseExampleOpAdaptor {
public:
  ParseExampleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions = {});
  ParseExampleOpAdaptor(ParseExampleOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value serialized();
  ::mlir::Value names();
  ::mlir::ValueRange sparse_keys();
  ::mlir::ValueRange dense_keys();
  ::mlir::ValueRange dense_defaults();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr dense_shapes();
  ::mlir::DenseIntElementsAttr result_segment_sizes();
  ::mlir::DenseIntElementsAttr operand_segment_sizes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ParseExampleOp : public ::mlir::Op<ParseExampleOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::AttrSizedResultSegments, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParseExampleOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dense_shapes"), ::llvm::StringRef("result_segment_sizes"), ::llvm::StringRef("operand_segment_sizes"), ::llvm::StringRef("Nsparse"), ::llvm::StringRef("Ndense"), ::llvm::StringRef("Tdense"), ::llvm::StringRef("sparse_types")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dense_shapesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dense_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier result_segment_sizesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier result_segment_sizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier operand_segment_sizesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier operand_segment_sizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier NsparseAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier NsparseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier NdenseAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier NdenseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier TdenseAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier TdenseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier sparse_typesAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier sparse_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ParseExample");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value serialized();
  ::mlir::Value names();
  ::mlir::Operation::operand_range sparse_keys();
  ::mlir::Operation::operand_range dense_keys();
  ::mlir::Operation::operand_range dense_defaults();
  ::mlir::MutableOperandRange serializedMutable();
  ::mlir::MutableOperandRange namesMutable();
  ::mlir::MutableOperandRange sparse_keysMutable();
  ::mlir::MutableOperandRange dense_keysMutable();
  ::mlir::MutableOperandRange dense_defaultsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range sparse_indices();
  ::mlir::Operation::result_range sparse_values();
  ::mlir::Operation::result_range sparse_shapes();
  ::mlir::Operation::result_range dense_values();
  ::mlir::ArrayAttr dense_shapesAttr();
  ::mlir::ArrayAttr dense_shapes();
  ::mlir::DenseIntElementsAttr result_segment_sizesAttr();
  ::mlir::DenseIntElementsAttr result_segment_sizes();
  ::mlir::DenseIntElementsAttr operand_segment_sizesAttr();
  ::mlir::DenseIntElementsAttr operand_segment_sizes();
  size_t Nsparse();
  size_t Ndense();
  mlir::OperandElementTypeRange Tdense();
  mlir::ResultElementTypeRange sparse_types();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dense_shapesAttr(::mlir::ArrayAttr attr);
  void result_segment_sizesAttr(::mlir::DenseIntElementsAttr attr);
  void operand_segment_sizesAttr(::mlir::DenseIntElementsAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange sparse_indices, ::mlir::TypeRange sparse_values, ::mlir::TypeRange sparse_shapes, ::mlir::TypeRange dense_values, ::mlir::Value serialized, ::mlir::Value names, ::mlir::ValueRange sparse_keys, ::mlir::ValueRange dense_keys, ::mlir::ValueRange dense_defaults, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes, ::mlir::DenseIntElementsAttr operand_segment_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value serialized, ::mlir::Value names, ::mlir::ValueRange sparse_keys, ::mlir::ValueRange dense_keys, ::mlir::ValueRange dense_defaults, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes, ::mlir::DenseIntElementsAttr operand_segment_sizes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ParseExampleOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParseExampleV2Op declarations
//===----------------------------------------------------------------------===//

class ParseExampleV2OpAdaptor {
public:
  ParseExampleV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ParseExampleV2OpAdaptor(ParseExampleV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value serialized();
  ::mlir::Value names();
  ::mlir::Value sparse_keys();
  ::mlir::Value dense_keys();
  ::mlir::Value ragged_keys();
  ::mlir::ValueRange dense_defaults();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr num_sparse();
  ::mlir::ArrayAttr dense_shapes();
  ::mlir::DenseIntElementsAttr result_segment_sizes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ParseExampleV2Op : public ::mlir::Op<ParseExampleV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::AttrSizedResultSegments, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParseExampleV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("num_sparse"), ::llvm::StringRef("dense_shapes"), ::llvm::StringRef("result_segment_sizes"), ::llvm::StringRef("Tdense"), ::llvm::StringRef("sparse_types"), ::llvm::StringRef("ragged_value_types"), ::llvm::StringRef("ragged_split_types")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier num_sparseAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier num_sparseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dense_shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dense_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier result_segment_sizesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier result_segment_sizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TdenseAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TdenseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier sparse_typesAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier sparse_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier ragged_value_typesAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier ragged_value_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier ragged_split_typesAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier ragged_split_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ParseExampleV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value serialized();
  ::mlir::Value names();
  ::mlir::Value sparse_keys();
  ::mlir::Value dense_keys();
  ::mlir::Value ragged_keys();
  ::mlir::Operation::operand_range dense_defaults();
  ::mlir::MutableOperandRange serializedMutable();
  ::mlir::MutableOperandRange namesMutable();
  ::mlir::MutableOperandRange sparse_keysMutable();
  ::mlir::MutableOperandRange dense_keysMutable();
  ::mlir::MutableOperandRange ragged_keysMutable();
  ::mlir::MutableOperandRange dense_defaultsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range sparse_indices();
  ::mlir::Operation::result_range sparse_values();
  ::mlir::Operation::result_range sparse_shapes();
  ::mlir::Operation::result_range dense_values();
  ::mlir::Operation::result_range ragged_values();
  ::mlir::Operation::result_range ragged_row_splits();
  ::mlir::IntegerAttr num_sparseAttr();
  uint64_t num_sparse();
  ::mlir::ArrayAttr dense_shapesAttr();
  ::mlir::ArrayAttr dense_shapes();
  ::mlir::DenseIntElementsAttr result_segment_sizesAttr();
  ::mlir::DenseIntElementsAttr result_segment_sizes();
  mlir::OperandElementTypeRange Tdense();
  mlir::ResultElementTypeRange sparse_types();
  mlir::ResultElementTypeRange ragged_value_types();
  mlir::ResultElementTypeRange ragged_split_types();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void num_sparseAttr(::mlir::IntegerAttr attr);
  void dense_shapesAttr(::mlir::ArrayAttr attr);
  void result_segment_sizesAttr(::mlir::DenseIntElementsAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange sparse_indices, ::mlir::TypeRange sparse_values, ::mlir::TypeRange sparse_shapes, ::mlir::TypeRange dense_values, ::mlir::TypeRange ragged_values, ::mlir::TypeRange ragged_row_splits, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, ::mlir::IntegerAttr num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, ::mlir::IntegerAttr num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange sparse_indices, ::mlir::TypeRange sparse_values, ::mlir::TypeRange sparse_shapes, ::mlir::TypeRange dense_values, ::mlir::TypeRange ragged_values, ::mlir::TypeRange ragged_row_splits, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, uint64_t num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, uint64_t num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ParseExampleV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PartitionedCallOp declarations
//===----------------------------------------------------------------------===//

class PartitionedCallOpAdaptor {
public:
  PartitionedCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PartitionedCallOpAdaptor(PartitionedCallOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange args();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr f();
  ::mlir::StringAttr config();
  ::mlir::StringAttr config_proto();
  ::mlir::StringAttr executor_type();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PartitionedCallOp : public ::mlir::Op<PartitionedCallOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::CallOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PartitionedCallOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("config"), ::llvm::StringRef("config_proto"), ::llvm::StringRef("executor_type"), ::llvm::StringRef("Tin"), ::llvm::StringRef("Tout")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier config_protoAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier config_protoAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier executor_typeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier executor_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier TinAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier TinAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier ToutAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier ToutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.PartitionedCall");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range args();
  ::mlir::MutableOperandRange argsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::SymbolRefAttr fAttr();
  ::mlir::SymbolRefAttr f();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  ::mlir::StringAttr config_protoAttr();
  ::llvm::StringRef config_proto();
  ::mlir::StringAttr executor_typeAttr();
  ::llvm::StringRef executor_type();
  mlir::OperandElementTypeRange Tin();
  mlir::ResultElementTypeRange Tout();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void fAttr(::mlir::SymbolRefAttr attr);
  void configAttr(::mlir::StringAttr attr);
  void config_protoAttr(::mlir::StringAttr attr);
  void executor_typeAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::SymbolRefAttr f, ::mlir::StringAttr config, ::mlir::StringAttr config_proto, ::mlir::StringAttr executor_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::SymbolRefAttr f, ::llvm::StringRef config, ::llvm::StringRef config_proto, ::llvm::StringRef executor_type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // Gets the argument operands to the called function.
    operand_range getArgOperands() { return args(); }

    // Returns the callee of this operation.
    CallInterfaceCallable getCallableForCallee() { return fAttr(); }

    // returns the callee of this operation.
    FuncOp func() {
      return SymbolTable::lookupNearestSymbolFrom<FuncOp>(*this, f());
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PartitionedCallOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PlaceholderOp declarations
//===----------------------------------------------------------------------===//

class PlaceholderOpAdaptor {
public:
  PlaceholderOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PlaceholderOpAdaptor(PlaceholderOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PlaceholderOp : public ::mlir::Op<PlaceholderOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PlaceholderOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Placeholder");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PlaceholderOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PlaceholderWithDefaultOp declarations
//===----------------------------------------------------------------------===//

class PlaceholderWithDefaultOpAdaptor {
public:
  PlaceholderWithDefaultOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PlaceholderWithDefaultOpAdaptor(PlaceholderWithDefaultOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PlaceholderWithDefaultOp : public ::mlir::Op<PlaceholderWithDefaultOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PlaceholderWithDefaultOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtype"), ::llvm::StringRef("shape")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier shapeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.PlaceholderWithDefault");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type dtype();
  ShapedType shape();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PlaceholderWithDefaultOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PolygammaOp declarations
//===----------------------------------------------------------------------===//

class PolygammaOpAdaptor {
public:
  PolygammaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PolygammaOpAdaptor(PolygammaOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PolygammaOp : public ::mlir::Op<PolygammaOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PolygammaOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Polygamma");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value x();
  ::mlir::MutableOperandRange aMutable();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value a, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PolygammaOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PopulationCountOp declarations
//===----------------------------------------------------------------------===//

class PopulationCountOpAdaptor {
public:
  PopulationCountOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PopulationCountOpAdaptor(PopulationCountOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PopulationCountOp : public ::mlir::Op<PopulationCountOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PopulationCountOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.PopulationCount");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PopulationCountOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PowOp declarations
//===----------------------------------------------------------------------===//

class PowOpAdaptor {
public:
  PowOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PowOpAdaptor(PowOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PowOp : public ::mlir::Op<PowOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::OpTrait::TF::SameOperandsAndResultElementTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PowOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Pow");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PowOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PrefetchDatasetOp declarations
//===----------------------------------------------------------------------===//

class PrefetchDatasetOpAdaptor {
public:
  PrefetchDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PrefetchDatasetOpAdaptor(PrefetchDatasetOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::IntegerAttr slack_period();
  ::mlir::BoolAttr legacy_autotune();
  ::mlir::IntegerAttr buffer_size_min();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PrefetchDatasetOp : public ::mlir::Op<PrefetchDatasetOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PrefetchDatasetOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes"), ::llvm::StringRef("slack_period"), ::llvm::StringRef("legacy_autotune"), ::llvm::StringRef("buffer_size_min")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier slack_periodAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier slack_periodAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier legacy_autotuneAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier legacy_autotuneAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier buffer_size_minAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier buffer_size_minAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.PrefetchDataset");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange buffer_sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::IntegerAttr slack_periodAttr();
  uint64_t slack_period();
  ::mlir::BoolAttr legacy_autotuneAttr();
  bool legacy_autotune();
  ::mlir::IntegerAttr buffer_size_minAttr();
  uint64_t buffer_size_min();
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  void slack_periodAttr(::mlir::IntegerAttr attr);
  void legacy_autotuneAttr(::mlir::BoolAttr attr);
  void buffer_size_minAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::IntegerAttr slack_period, ::mlir::BoolAttr legacy_autotune, ::mlir::IntegerAttr buffer_size_min);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::IntegerAttr slack_period, ::mlir::BoolAttr legacy_autotune, ::mlir::IntegerAttr buffer_size_min);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, uint64_t slack_period = 0, bool legacy_autotune = true, uint64_t buffer_size_min = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, uint64_t slack_period = 0, bool legacy_autotune = true, uint64_t buffer_size_min = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PrefetchDatasetOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PreventGradientOp declarations
//===----------------------------------------------------------------------===//

class PreventGradientOpAdaptor {
public:
  PreventGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PreventGradientOpAdaptor(PreventGradientOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr message();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PreventGradientOp : public ::mlir::Op<PreventGradientOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PreventGradientOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("message"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier messageAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier messageAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.PreventGradient");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr messageAttr();
  ::llvm::StringRef message();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void messageAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::StringAttr message);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr message);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::llvm::StringRef message);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef message);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PreventGradientOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PrintOp declarations
//===----------------------------------------------------------------------===//

class PrintOpAdaptor {
public:
  PrintOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PrintOpAdaptor(PrintOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::ValueRange data();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr message();
  ::mlir::IntegerAttr first_n();
  ::mlir::IntegerAttr summarize();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PrintOp : public ::mlir::Op<PrintOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PrintOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("message"), ::llvm::StringRef("first_n"), ::llvm::StringRef("summarize"), ::llvm::StringRef("T"), ::llvm::StringRef("U")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier messageAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier messageAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier first_nAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier first_nAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier summarizeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier summarizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier UAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier UAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Print");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Operation::operand_range data();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange dataMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr messageAttr();
  ::llvm::StringRef message();
  ::mlir::IntegerAttr first_nAttr();
  uint64_t first_n();
  ::mlir::IntegerAttr summarizeAttr();
  uint64_t summarize();
  ::mlir::Type T();
  mlir::OperandElementTypeRange U();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void messageAttr(::mlir::StringAttr attr);
  void first_nAttr(::mlir::IntegerAttr attr);
  void summarizeAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ValueRange data, ::mlir::StringAttr message, ::mlir::IntegerAttr first_n, ::mlir::IntegerAttr summarize);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ValueRange data, ::mlir::StringAttr message, ::mlir::IntegerAttr first_n, ::mlir::IntegerAttr summarize);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ValueRange data, ::llvm::StringRef message, uint64_t first_n = -1, uint64_t summarize = 3);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ValueRange data, ::llvm::StringRef message, uint64_t first_n = -1, uint64_t summarize = 3);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PrintOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PrintV2Op declarations
//===----------------------------------------------------------------------===//

class PrintV2OpAdaptor {
public:
  PrintV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  PrintV2OpAdaptor(PrintV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr output_stream();
  ::mlir::StringAttr end();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class PrintV2Op : public ::mlir::Op<PrintV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PrintV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_stream"), ::llvm::StringRef("end")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_streamAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_streamAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier endAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier endAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.PrintV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::StringAttr output_streamAttr();
  ::llvm::StringRef output_stream();
  ::mlir::StringAttr endAttr();
  ::llvm::StringRef end();
  void output_streamAttr(::mlir::StringAttr attr);
  void endAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::StringAttr output_stream, ::mlir::StringAttr end);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr output_stream, ::mlir::StringAttr end);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::llvm::StringRef output_stream, ::llvm::StringRef end);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef output_stream, ::llvm::StringRef end);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::PrintV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ProdOp declarations
//===----------------------------------------------------------------------===//

class ProdOpAdaptor {
public:
  ProdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ProdOpAdaptor(ProdOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value reduction_indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr keep_dims();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ProdOp : public ::mlir::Op<ProdOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ProdOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("keep_dims"), ::llvm::StringRef("T"), ::llvm::StringRef("Tidx")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier keep_dimsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier keep_dimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Prod");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value reduction_indices();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange reduction_indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr keep_dimsAttr();
  bool keep_dims();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void keep_dimsAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ProdOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QrOp declarations
//===----------------------------------------------------------------------===//

class QrOpAdaptor {
public:
  QrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  QrOpAdaptor(QrOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr full_matrices();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class QrOp : public ::mlir::Op<QrOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = QrOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("full_matrices"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier full_matricesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier full_matricesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Qr");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value q();
  ::mlir::Value r();
  ::mlir::BoolAttr full_matricesAttr();
  bool full_matrices();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void full_matricesAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type q, ::mlir::Type r, ::mlir::Value input, ::mlir::BoolAttr full_matrices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr full_matrices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type q, ::mlir::Type r, ::mlir::Value input, bool full_matrices = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool full_matrices = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::QrOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QuantizeAndDequantizeOp declarations
//===----------------------------------------------------------------------===//

class QuantizeAndDequantizeOpAdaptor {
public:
  QuantizeAndDequantizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  QuantizeAndDequantizeOpAdaptor(QuantizeAndDequantizeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr signed_input();
  ::mlir::IntegerAttr num_bits();
  ::mlir::BoolAttr range_given();
  ::mlir::FloatAttr input_min();
  ::mlir::FloatAttr input_max();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class QuantizeAndDequantizeOp : public ::mlir::Op<QuantizeAndDequantizeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = QuantizeAndDequantizeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("signed_input"), ::llvm::StringRef("num_bits"), ::llvm::StringRef("range_given"), ::llvm::StringRef("input_min"), ::llvm::StringRef("input_max"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier signed_inputAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier signed_inputAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier num_bitsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier num_bitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier range_givenAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier range_givenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier input_minAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier input_minAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier input_maxAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier input_maxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.QuantizeAndDequantize");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr signed_inputAttr();
  bool signed_input();
  ::mlir::IntegerAttr num_bitsAttr();
  uint64_t num_bits();
  ::mlir::BoolAttr range_givenAttr();
  bool range_given();
  ::mlir::FloatAttr input_minAttr();
  ::llvm::APFloat input_min();
  ::mlir::FloatAttr input_maxAttr();
  ::llvm::APFloat input_max();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void signed_inputAttr(::mlir::BoolAttr attr);
  void num_bitsAttr(::mlir::IntegerAttr attr);
  void range_givenAttr(::mlir::BoolAttr attr);
  void input_minAttr(::mlir::FloatAttr attr);
  void input_maxAttr(::mlir::FloatAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::FloatAttr input_min, ::mlir::FloatAttr input_max);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::FloatAttr input_min, ::mlir::FloatAttr input_max);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, bool signed_input, uint64_t num_bits, bool range_given, ::llvm::APFloat input_min, ::llvm::APFloat input_max);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool signed_input, uint64_t num_bits, bool range_given, ::llvm::APFloat input_min, ::llvm::APFloat input_max);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::QuantizeAndDequantizeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QuantizeAndDequantizeV2Op declarations
//===----------------------------------------------------------------------===//

class QuantizeAndDequantizeV2OpAdaptor {
public:
  QuantizeAndDequantizeV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  QuantizeAndDequantizeV2OpAdaptor(QuantizeAndDequantizeV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value input_min();
  ::mlir::Value input_max();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr signed_input();
  ::mlir::IntegerAttr num_bits();
  ::mlir::BoolAttr range_given();
  ::mlir::StringAttr round_mode();
  ::mlir::BoolAttr narrow_range();
  ::mlir::IntegerAttr axis();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class QuantizeAndDequantizeV2Op : public ::mlir::Op<QuantizeAndDequantizeV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = QuantizeAndDequantizeV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("signed_input"), ::llvm::StringRef("num_bits"), ::llvm::StringRef("range_given"), ::llvm::StringRef("round_mode"), ::llvm::StringRef("narrow_range"), ::llvm::StringRef("axis"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier signed_inputAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier signed_inputAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier num_bitsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier num_bitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier range_givenAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier range_givenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier round_modeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier round_modeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier narrow_rangeAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier narrow_rangeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier axisAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier axisAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.QuantizeAndDequantizeV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value input_min();
  ::mlir::Value input_max();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange input_minMutable();
  ::mlir::MutableOperandRange input_maxMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr signed_inputAttr();
  bool signed_input();
  ::mlir::IntegerAttr num_bitsAttr();
  uint64_t num_bits();
  ::mlir::BoolAttr range_givenAttr();
  bool range_given();
  ::mlir::StringAttr round_modeAttr();
  ::llvm::StringRef round_mode();
  ::mlir::BoolAttr narrow_rangeAttr();
  bool narrow_range();
  ::mlir::IntegerAttr axisAttr();
  uint64_t axis();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void signed_inputAttr(::mlir::BoolAttr attr);
  void num_bitsAttr(::mlir::IntegerAttr attr);
  void range_givenAttr(::mlir::BoolAttr attr);
  void round_modeAttr(::mlir::StringAttr attr);
  void narrow_rangeAttr(::mlir::BoolAttr attr);
  void axisAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::StringAttr round_mode, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::StringAttr round_mode, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, bool signed_input = true, uint64_t num_bits = 8, bool range_given = false, ::llvm::StringRef round_mode = "HALF_TO_EVEN", bool narrow_range = false, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, bool signed_input = true, uint64_t num_bits = 8, bool range_given = false, ::llvm::StringRef round_mode = "HALF_TO_EVEN", bool narrow_range = false, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::QuantizeAndDequantizeV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QuantizeAndDequantizeV3Op declarations
//===----------------------------------------------------------------------===//

class QuantizeAndDequantizeV3OpAdaptor {
public:
  QuantizeAndDequantizeV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  QuantizeAndDequantizeV3OpAdaptor(QuantizeAndDequantizeV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value input_min();
  ::mlir::Value input_max();
  ::mlir::Value num_bits();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr signed_input();
  ::mlir::BoolAttr range_given();
  ::mlir::BoolAttr narrow_range();
  ::mlir::IntegerAttr axis();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class QuantizeAndDequantizeV3Op : public ::mlir::Op<QuantizeAndDequantizeV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = QuantizeAndDequantizeV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("signed_input"), ::llvm::StringRef("range_given"), ::llvm::StringRef("narrow_range"), ::llvm::StringRef("axis"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier signed_inputAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier signed_inputAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier range_givenAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier range_givenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier narrow_rangeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier narrow_rangeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier axisAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier axisAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.QuantizeAndDequantizeV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value input_min();
  ::mlir::Value input_max();
  ::mlir::Value num_bits();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange input_minMutable();
  ::mlir::MutableOperandRange input_maxMutable();
  ::mlir::MutableOperandRange num_bitsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr signed_inputAttr();
  bool signed_input();
  ::mlir::BoolAttr range_givenAttr();
  bool range_given();
  ::mlir::BoolAttr narrow_rangeAttr();
  bool narrow_range();
  ::mlir::IntegerAttr axisAttr();
  uint64_t axis();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void signed_inputAttr(::mlir::BoolAttr attr);
  void range_givenAttr(::mlir::BoolAttr attr);
  void narrow_rangeAttr(::mlir::BoolAttr attr);
  void axisAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, ::mlir::BoolAttr signed_input, ::mlir::BoolAttr range_given, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, ::mlir::BoolAttr signed_input, ::mlir::BoolAttr range_given, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, bool signed_input = true, bool range_given = true, bool narrow_range = false, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, bool signed_input = true, bool range_given = true, bool narrow_range = false, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::QuantizeAndDequantizeV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QuantizeAndDequantizeV4Op declarations
//===----------------------------------------------------------------------===//

class QuantizeAndDequantizeV4OpAdaptor {
public:
  QuantizeAndDequantizeV4OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  QuantizeAndDequantizeV4OpAdaptor(QuantizeAndDequantizeV4Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value input_min();
  ::mlir::Value input_max();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr signed_input();
  ::mlir::IntegerAttr num_bits();
  ::mlir::BoolAttr range_given();
  ::mlir::StringAttr round_mode();
  ::mlir::BoolAttr narrow_range();
  ::mlir::IntegerAttr axis();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class QuantizeAndDequantizeV4Op : public ::mlir::Op<QuantizeAndDequantizeV4Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = QuantizeAndDequantizeV4OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("signed_input"), ::llvm::StringRef("num_bits"), ::llvm::StringRef("range_given"), ::llvm::StringRef("round_mode"), ::llvm::StringRef("narrow_range"), ::llvm::StringRef("axis"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier signed_inputAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier signed_inputAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier num_bitsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier num_bitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier range_givenAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier range_givenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier round_modeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier round_modeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier narrow_rangeAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier narrow_rangeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier axisAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier axisAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.QuantizeAndDequantizeV4");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value input_min();
  ::mlir::Value input_max();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange input_minMutable();
  ::mlir::MutableOperandRange input_maxMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr signed_inputAttr();
  bool signed_input();
  ::mlir::IntegerAttr num_bitsAttr();
  uint64_t num_bits();
  ::mlir::BoolAttr range_givenAttr();
  bool range_given();
  ::mlir::StringAttr round_modeAttr();
  ::llvm::StringRef round_mode();
  ::mlir::BoolAttr narrow_rangeAttr();
  bool narrow_range();
  ::mlir::IntegerAttr axisAttr();
  uint64_t axis();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void signed_inputAttr(::mlir::BoolAttr attr);
  void num_bitsAttr(::mlir::IntegerAttr attr);
  void range_givenAttr(::mlir::BoolAttr attr);
  void round_modeAttr(::mlir::StringAttr attr);
  void narrow_rangeAttr(::mlir::BoolAttr attr);
  void axisAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::StringAttr round_mode, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::StringAttr round_mode, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, bool signed_input = true, uint64_t num_bits = 8, bool range_given = false, ::llvm::StringRef round_mode = "HALF_TO_EVEN", bool narrow_range = false, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, bool signed_input = true, uint64_t num_bits = 8, bool range_given = false, ::llvm::StringRef round_mode = "HALF_TO_EVEN", bool narrow_range = false, uint64_t axis = -1);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::QuantizeAndDequantizeV4Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QueueDequeueV2Op declarations
//===----------------------------------------------------------------------===//

class QueueDequeueV2OpAdaptor {
public:
  QueueDequeueV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  QueueDequeueV2OpAdaptor(QueueDequeueV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr timeout_ms();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class QueueDequeueV2Op : public ::mlir::Op<QueueDequeueV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = QueueDequeueV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("timeout_ms"), ::llvm::StringRef("component_types")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier timeout_msAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier timeout_msAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier component_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier component_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.QueueDequeueV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::MutableOperandRange handleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range components();
  ::mlir::IntegerAttr timeout_msAttr();
  uint64_t timeout_ms();
  mlir::ResultElementTypeRange component_types();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void timeout_msAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value handle, ::mlir::IntegerAttr timeout_ms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value handle, uint64_t timeout_ms = -1);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::QueueDequeueV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RFFT2DOp declarations
//===----------------------------------------------------------------------===//

class RFFT2DOpAdaptor {
public:
  RFFT2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RFFT2DOpAdaptor(RFFT2DOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value fft_length();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RFFT2DOp : public ::mlir::Op<RFFT2DOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RFFT2DOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Treal"), ::llvm::StringRef("Tcomplex")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TrealAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TrealAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TcomplexAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TcomplexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RFFT2D");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value fft_length();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange fft_lengthMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Treal();
  ::mlir::Type Tcomplex();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RFFT2DOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RFFT3DOp declarations
//===----------------------------------------------------------------------===//

class RFFT3DOpAdaptor {
public:
  RFFT3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RFFT3DOpAdaptor(RFFT3DOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value fft_length();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RFFT3DOp : public ::mlir::Op<RFFT3DOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RFFT3DOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Treal"), ::llvm::StringRef("Tcomplex")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TrealAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TrealAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TcomplexAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TcomplexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RFFT3D");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value fft_length();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange fft_lengthMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Treal();
  ::mlir::Type Tcomplex();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RFFT3DOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RFFTOp declarations
//===----------------------------------------------------------------------===//

class RFFTOpAdaptor {
public:
  RFFTOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RFFTOpAdaptor(RFFTOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value fft_length();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RFFTOp : public ::mlir::Op<RFFTOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RFFTOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Treal"), ::llvm::StringRef("Tcomplex")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TrealAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TrealAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TcomplexAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TcomplexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RFFT");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value fft_length();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange fft_lengthMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Treal();
  ::mlir::Type Tcomplex();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RFFTOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RGBToHSVOp declarations
//===----------------------------------------------------------------------===//

class RGBToHSVOpAdaptor {
public:
  RGBToHSVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RGBToHSVOpAdaptor(RGBToHSVOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value images();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RGBToHSVOp : public ::mlir::Op<RGBToHSVOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RGBToHSVOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RGBToHSV");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value images();
  ::mlir::MutableOperandRange imagesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value images);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RGBToHSVOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RaggedGatherOp declarations
//===----------------------------------------------------------------------===//

class RaggedGatherOpAdaptor {
public:
  RaggedGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RaggedGatherOpAdaptor(RaggedGatherOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange params_nested_splits();
  ::mlir::Value params_dense_values();
  ::mlir::Value indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RaggedGatherOp : public ::mlir::Op<RaggedGatherOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::AtLeastNResults<1>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RaggedGatherOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("PARAMS_RAGGED_RANK"), ::llvm::StringRef("Tindices"), ::llvm::StringRef("Tsplits"), ::llvm::StringRef("Tvalues"), ::llvm::StringRef("OUTPUT_RAGGED_RANK")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier PARAMS_RAGGED_RANKAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier PARAMS_RAGGED_RANKAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TsplitsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TsplitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TvaluesAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TvaluesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier OUTPUT_RAGGED_RANKAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier OUTPUT_RAGGED_RANKAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RaggedGather");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range params_nested_splits();
  ::mlir::Value params_dense_values();
  ::mlir::Value indices();
  ::mlir::MutableOperandRange params_nested_splitsMutable();
  ::mlir::MutableOperandRange params_dense_valuesMutable();
  ::mlir::MutableOperandRange indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output_nested_splits();
  ::mlir::Value output_dense_values();
  size_t PARAMS_RAGGED_RANK();
  ::mlir::Type Tindices();
  ::mlir::Type Tsplits();
  ::mlir::Type Tvalues();
  size_t OUTPUT_RAGGED_RANK();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output_nested_splits, ::mlir::Type output_dense_values, ::mlir::ValueRange params_nested_splits, ::mlir::Value params_dense_values, ::mlir::Value indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange params_nested_splits, ::mlir::Value params_dense_values, ::mlir::Value indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RaggedGatherOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RaggedRangeOp declarations
//===----------------------------------------------------------------------===//

class RaggedRangeOpAdaptor {
public:
  RaggedRangeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RaggedRangeOpAdaptor(RaggedRangeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value starts();
  ::mlir::Value limits();
  ::mlir::Value deltas();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RaggedRangeOp : public ::mlir::Op<RaggedRangeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RaggedRangeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tsplits")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TsplitsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TsplitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RaggedRange");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value starts();
  ::mlir::Value limits();
  ::mlir::Value deltas();
  ::mlir::MutableOperandRange startsMutable();
  ::mlir::MutableOperandRange limitsMutable();
  ::mlir::MutableOperandRange deltasMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value rt_nested_splits();
  ::mlir::Value rt_dense_values();
  ::mlir::Type T();
  ::mlir::Type Tsplits();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type rt_nested_splits, ::mlir::Type rt_dense_values, ::mlir::Value starts, ::mlir::Value limits, ::mlir::Value deltas);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value starts, ::mlir::Value limits, ::mlir::Value deltas);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RaggedRangeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomGammaGradOp declarations
//===----------------------------------------------------------------------===//

class RandomGammaGradOpAdaptor {
public:
  RandomGammaGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomGammaGradOpAdaptor(RandomGammaGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value alpha();
  ::mlir::Value sample();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomGammaGradOp : public ::mlir::Op<RandomGammaGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomGammaGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomGammaGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value alpha();
  ::mlir::Value sample();
  ::mlir::MutableOperandRange alphaMutable();
  ::mlir::MutableOperandRange sampleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value alpha, ::mlir::Value sample);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value alpha, ::mlir::Value sample);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomGammaGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomGammaOp declarations
//===----------------------------------------------------------------------===//

class RandomGammaOpAdaptor {
public:
  RandomGammaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomGammaOpAdaptor(RandomGammaOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value alpha();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomGammaOp : public ::mlir::Op<RandomGammaOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomGammaOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("S"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier SAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier SAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomGamma");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value alpha();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange alphaMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type S();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value alpha, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value alpha, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value alpha, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value alpha, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomGammaOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomPoissonOp declarations
//===----------------------------------------------------------------------===//

class RandomPoissonOpAdaptor {
public:
  RandomPoissonOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomPoissonOpAdaptor(RandomPoissonOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value rate();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomPoissonOp : public ::mlir::Op<RandomPoissonOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomPoissonOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("S"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier SAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier SAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomPoisson");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value rate();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange rateMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type S();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomPoissonOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomPoissonV2Op declarations
//===----------------------------------------------------------------------===//

class RandomPoissonV2OpAdaptor {
public:
  RandomPoissonV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomPoissonV2OpAdaptor(RandomPoissonV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value rate();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomPoissonV2Op : public ::mlir::Op<RandomPoissonV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomPoissonV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("R"), ::llvm::StringRef("S"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier RAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier RAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier SAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier SAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomPoissonV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value rate();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange rateMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type R();
  ::mlir::Type S();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomPoissonV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomShuffleOp declarations
//===----------------------------------------------------------------------===//

class RandomShuffleOpAdaptor {
public:
  RandomShuffleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomShuffleOpAdaptor(RandomShuffleOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomShuffleOp : public ::mlir::Op<RandomShuffleOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomShuffleOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomShuffle");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value value();
  ::mlir::MutableOperandRange valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomShuffleOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomStandardNormalOp declarations
//===----------------------------------------------------------------------===//

class RandomStandardNormalOpAdaptor {
public:
  RandomStandardNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomStandardNormalOpAdaptor(RandomStandardNormalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomStandardNormalOp : public ::mlir::Op<RandomStandardNormalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomStandardNormalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("T"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomStandardNormal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type T();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomStandardNormalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomUniformIntOp declarations
//===----------------------------------------------------------------------===//

class RandomUniformIntOpAdaptor {
public:
  RandomUniformIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomUniformIntOpAdaptor(RandomUniformIntOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomUniformIntOp : public ::mlir::Op<RandomUniformIntOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomUniformIntOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("T"), ::llvm::StringRef("Tout")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier ToutAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier ToutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomUniformInt");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange minvalMutable();
  ::mlir::MutableOperandRange maxvalMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type T();
  ::mlir::Type Tout();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomUniformIntOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomUniformOp declarations
//===----------------------------------------------------------------------===//

class RandomUniformOpAdaptor {
public:
  RandomUniformOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RandomUniformOpAdaptor(RandomUniformOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RandomUniformOp : public ::mlir::Op<RandomUniformOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RandomUniformOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("T"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RandomUniform");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type T();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RandomUniformOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RangeDatasetOp declarations
//===----------------------------------------------------------------------===//

class RangeDatasetOpAdaptor {
public:
  RangeDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RangeDatasetOpAdaptor(RangeDatasetOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value start();
  ::mlir::Value stop();
  ::mlir::Value step();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RangeDatasetOp : public ::mlir::Op<RangeDatasetOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RangeDatasetOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RangeDataset");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value start();
  ::mlir::Value stop();
  ::mlir::Value step();
  ::mlir::MutableOperandRange startMutable();
  ::mlir::MutableOperandRange stopMutable();
  ::mlir::MutableOperandRange stepMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value start, ::mlir::Value stop, ::mlir::Value step, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value start, ::mlir::Value stop, ::mlir::Value step, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RangeDatasetOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RangeOp declarations
//===----------------------------------------------------------------------===//

class RangeOpAdaptor {
public:
  RangeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RangeOpAdaptor(RangeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value start();
  ::mlir::Value limit();
  ::mlir::Value delta();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RangeOp : public ::mlir::Op<RangeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultElementTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RangeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tidx")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Range");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value start();
  ::mlir::Value limit();
  ::mlir::Value delta();
  ::mlir::MutableOperandRange startMutable();
  ::mlir::MutableOperandRange limitMutable();
  ::mlir::MutableOperandRange deltaMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Tidx();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value start, Value limit, Value delta);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value start, ::mlir::Value limit, ::mlir::Value delta);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value start, ::mlir::Value limit, ::mlir::Value delta);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RangeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RankOp declarations
//===----------------------------------------------------------------------===//

class RankOpAdaptor {
public:
  RankOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RankOpAdaptor(RankOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RankOp : public ::mlir::Op<RankOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RankOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Rank");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RankOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReadVariableOp declarations
//===----------------------------------------------------------------------===//

class ReadVariableOpAdaptor {
public:
  ReadVariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReadVariableOpAdaptor(ReadVariableOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReadVariableOp : public ::mlir::Op<ReadVariableOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReadVariableOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ReadVariableOp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::MutableOperandRange resourceMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value value();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value resource);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReadVariableOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RealDivOp declarations
//===----------------------------------------------------------------------===//

class RealDivOpAdaptor {
public:
  RealDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RealDivOpAdaptor(RealDivOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RealDivOp : public ::mlir::Op<RealDivOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::OpTrait::TF::CwiseBinary, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RealDivOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RealDiv");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RealDivOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RealOp declarations
//===----------------------------------------------------------------------===//

class RealOpAdaptor {
public:
  RealOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RealOpAdaptor(RealOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RealOp : public ::mlir::Op<RealOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RealOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tout")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier ToutAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier ToutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Real");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tout();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RealOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReciprocalGradOp declarations
//===----------------------------------------------------------------------===//

class ReciprocalGradOpAdaptor {
public:
  ReciprocalGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReciprocalGradOpAdaptor(ReciprocalGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReciprocalGradOp : public ::mlir::Op<ReciprocalGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReciprocalGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ReciprocalGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::MutableOperandRange yMutable();
  ::mlir::MutableOperandRange dyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReciprocalGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReciprocalOp declarations
//===----------------------------------------------------------------------===//

class ReciprocalOpAdaptor {
public:
  ReciprocalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReciprocalOpAdaptor(ReciprocalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReciprocalOp : public ::mlir::Op<ReciprocalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsInvolution, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReciprocalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Reciprocal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReciprocalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RecvOp declarations
//===----------------------------------------------------------------------===//

class RecvOpAdaptor {
public:
  RecvOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RecvOpAdaptor(RecvOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr tensor_name();
  ::mlir::StringAttr send_device();
  ::mlir::IntegerAttr send_device_incarnation();
  ::mlir::StringAttr recv_device();
  ::mlir::BoolAttr client_terminated();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RecvOp : public ::mlir::Op<RecvOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RecvOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("tensor_name"), ::llvm::StringRef("send_device"), ::llvm::StringRef("send_device_incarnation"), ::llvm::StringRef("recv_device"), ::llvm::StringRef("client_terminated"), ::llvm::StringRef("tensor_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier tensor_nameAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier tensor_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier send_deviceAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier send_deviceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier send_device_incarnationAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier send_device_incarnationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier recv_deviceAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier recv_deviceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier client_terminatedAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier client_terminatedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier tensor_typeAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier tensor_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Recv");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value tensor();
  ::mlir::StringAttr tensor_nameAttr();
  ::llvm::StringRef tensor_name();
  ::mlir::StringAttr send_deviceAttr();
  ::llvm::StringRef send_device();
  ::mlir::IntegerAttr send_device_incarnationAttr();
  uint64_t send_device_incarnation();
  ::mlir::StringAttr recv_deviceAttr();
  ::llvm::StringRef recv_device();
  ::mlir::BoolAttr client_terminatedAttr();
  bool client_terminated();
  ::mlir::Type tensor_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void tensor_nameAttr(::mlir::StringAttr attr);
  void send_deviceAttr(::mlir::StringAttr attr);
  void send_device_incarnationAttr(::mlir::IntegerAttr attr);
  void recv_deviceAttr(::mlir::StringAttr attr);
  void client_terminatedAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::StringAttr tensor_name, ::mlir::StringAttr send_device, ::mlir::IntegerAttr send_device_incarnation, ::mlir::StringAttr recv_device, ::mlir::BoolAttr client_terminated);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr tensor_name, ::mlir::StringAttr send_device, ::mlir::IntegerAttr send_device_incarnation, ::mlir::StringAttr recv_device, ::mlir::BoolAttr client_terminated);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::llvm::StringRef tensor_name, ::llvm::StringRef send_device, uint64_t send_device_incarnation, ::llvm::StringRef recv_device, bool client_terminated = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef tensor_name, ::llvm::StringRef send_device, uint64_t send_device_incarnation, ::llvm::StringRef recv_device, bool client_terminated = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RecvOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RecvTPUEmbeddingActivationsOp declarations
//===----------------------------------------------------------------------===//

class RecvTPUEmbeddingActivationsOpAdaptor {
public:
  RecvTPUEmbeddingActivationsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RecvTPUEmbeddingActivationsOpAdaptor(RecvTPUEmbeddingActivationsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RecvTPUEmbeddingActivationsOp : public ::mlir::Op<RecvTPUEmbeddingActivationsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RecvTPUEmbeddingActivationsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("config"), ::llvm::StringRef("num_outputs")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier num_outputsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier num_outputsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RecvTPUEmbeddingActivations");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range outputs();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  size_t num_outputs();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RecvTPUEmbeddingActivationsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReduceDatasetOp declarations
//===----------------------------------------------------------------------===//

class ReduceDatasetOpAdaptor {
public:
  ReduceDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReduceDatasetOpAdaptor(ReduceDatasetOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::ValueRange initial_state();
  ::mlir::ValueRange other_arguments();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr f();
  ::mlir::ArrayAttr Tstate();
  ::mlir::ArrayAttr Targuments();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr use_inter_op_parallelism();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReduceDatasetOp : public ::mlir::Op<ReduceDatasetOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<1>::Impl> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceDatasetOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("Tstate"), ::llvm::StringRef("Targuments"), ::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes"), ::llvm::StringRef("use_inter_op_parallelism")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TstateAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TstateAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TargumentsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TargumentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier use_inter_op_parallelismAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier use_inter_op_parallelismAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ReduceDataset");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Operation::operand_range initial_state();
  ::mlir::Operation::operand_range other_arguments();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange initial_stateMutable();
  ::mlir::MutableOperandRange other_argumentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range components();
  ::mlir::SymbolRefAttr fAttr();
  ::mlir::SymbolRefAttr f();
  ::mlir::ArrayAttr TstateAttr();
  ::mlir::ArrayAttr Tstate();
  ::mlir::ArrayAttr TargumentsAttr();
  ::mlir::ArrayAttr Targuments();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr use_inter_op_parallelismAttr();
  bool use_inter_op_parallelism();
  void fAttr(::mlir::SymbolRefAttr attr);
  void TstateAttr(::mlir::ArrayAttr attr);
  void TargumentsAttr(::mlir::ArrayAttr attr);
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  void use_inter_op_parallelismAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value input_dataset, ::mlir::ValueRange initial_state, ::mlir::ValueRange other_arguments, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr Tstate, ::mlir::ArrayAttr Targuments, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value input_dataset, ::mlir::ValueRange initial_state, ::mlir::ValueRange other_arguments, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr Tstate, ::mlir::ArrayAttr Targuments, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReduceDatasetOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReduceJoinOp declarations
//===----------------------------------------------------------------------===//

class ReduceJoinOpAdaptor {
public:
  ReduceJoinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReduceJoinOpAdaptor(ReduceJoinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value inputs();
  ::mlir::Value reduction_indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr keep_dims();
  ::mlir::StringAttr separator();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReduceJoinOp : public ::mlir::Op<ReduceJoinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceJoinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("keep_dims"), ::llvm::StringRef("separator")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier keep_dimsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier keep_dimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier separatorAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier separatorAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ReduceJoin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value inputs();
  ::mlir::Value reduction_indices();
  ::mlir::MutableOperandRange inputsMutable();
  ::mlir::MutableOperandRange reduction_indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr keep_dimsAttr();
  bool keep_dims();
  ::mlir::StringAttr separatorAttr();
  ::llvm::StringRef separator();
  void keep_dimsAttr(::mlir::BoolAttr attr);
  void separatorAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value inputs, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims, ::mlir::StringAttr separator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims, ::mlir::StringAttr separator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value inputs, ::mlir::Value reduction_indices, bool keep_dims, ::llvm::StringRef separator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::mlir::Value reduction_indices, bool keep_dims, ::llvm::StringRef separator);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReduceJoinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Relu6GradOp declarations
//===----------------------------------------------------------------------===//

class Relu6GradOpAdaptor {
public:
  Relu6GradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  Relu6GradOpAdaptor(Relu6GradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class Relu6GradOp : public ::mlir::Op<Relu6GradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Relu6GradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Relu6Grad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::MutableOperandRange gradientsMutable();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value backprops();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::Relu6GradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Relu6Op declarations
//===----------------------------------------------------------------------===//

class Relu6OpAdaptor {
public:
  Relu6OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  Relu6OpAdaptor(Relu6Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class Relu6Op : public ::mlir::Op<Relu6Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsIdempotent, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Relu6OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Relu6");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value activations();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::Relu6Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReluGradOp declarations
//===----------------------------------------------------------------------===//

class ReluGradOpAdaptor {
public:
  ReluGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReluGradOpAdaptor(ReluGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReluGradOp : public ::mlir::Op<ReluGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReluGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ReluGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::MutableOperandRange gradientsMutable();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value backprops();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReluGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReluOp declarations
//===----------------------------------------------------------------------===//

class ReluOpAdaptor {
public:
  ReluOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReluOpAdaptor(ReluOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReluOp : public ::mlir::Op<ReluOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsIdempotent, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::OpTrait::TF::LayoutAgnostic, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReluOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Relu");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value activations();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReluOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RemoteCallOp declarations
//===----------------------------------------------------------------------===//

class RemoteCallOpAdaptor {
public:
  RemoteCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RemoteCallOpAdaptor(RemoteCallOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value target();
  ::mlir::ValueRange args();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr f();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RemoteCallOp : public ::mlir::Op<RemoteCallOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RemoteCallOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("Tin"), ::llvm::StringRef("Tout")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TinAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TinAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier ToutAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier ToutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RemoteCall");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value target();
  ::mlir::Operation::operand_range args();
  ::mlir::MutableOperandRange targetMutable();
  ::mlir::MutableOperandRange argsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::SymbolRefAttr fAttr();
  ::mlir::SymbolRefAttr f();
  mlir::OperandElementTypeRange Tin();
  mlir::ResultElementTypeRange Tout();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void fAttr(::mlir::SymbolRefAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value target, ::mlir::ValueRange args, ::mlir::SymbolRefAttr f);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RemoteCallOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RepeatDatasetOp declarations
//===----------------------------------------------------------------------===//

class RepeatDatasetOpAdaptor {
public:
  RepeatDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RepeatDatasetOpAdaptor(RepeatDatasetOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value count();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RepeatDatasetOp : public ::mlir::Op<RepeatDatasetOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RepeatDatasetOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RepeatDataset");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value count();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange countMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value count, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value count, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RepeatDatasetOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReshapeOp declarations
//===----------------------------------------------------------------------===//

class ReshapeOpAdaptor {
public:
  ReshapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReshapeOpAdaptor(ReshapeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReshapeOp : public ::mlir::Op<ReshapeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReshapeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tshape")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TshapeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TshapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Reshape");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value shape();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tshape();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value tensor, Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReshapeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeBilinearGradOp declarations
//===----------------------------------------------------------------------===//

class ResizeBilinearGradOpAdaptor {
public:
  ResizeBilinearGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResizeBilinearGradOpAdaptor(ResizeBilinearGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value grads();
  ::mlir::Value original_image();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr align_corners();
  ::mlir::BoolAttr half_pixel_centers();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResizeBilinearGradOp : public ::mlir::Op<ResizeBilinearGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResizeBilinearGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("align_corners"), ::llvm::StringRef("half_pixel_centers"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier align_cornersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier align_cornersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier half_pixel_centersAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier half_pixel_centersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResizeBilinearGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value grads();
  ::mlir::Value original_image();
  ::mlir::MutableOperandRange gradsMutable();
  ::mlir::MutableOperandRange original_imageMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr align_cornersAttr();
  bool align_corners();
  ::mlir::BoolAttr half_pixel_centersAttr();
  bool half_pixel_centers();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void align_cornersAttr(::mlir::BoolAttr attr);
  void half_pixel_centersAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value original_image, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value original_image, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value original_image, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value original_image, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResizeBilinearGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeBilinearOp declarations
//===----------------------------------------------------------------------===//

class ResizeBilinearOpAdaptor {
public:
  ResizeBilinearOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResizeBilinearOpAdaptor(ResizeBilinearOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value images();
  ::mlir::Value size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr align_corners();
  ::mlir::BoolAttr half_pixel_centers();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResizeBilinearOp : public ::mlir::Op<ResizeBilinearOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResizeBilinearOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("align_corners"), ::llvm::StringRef("half_pixel_centers"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier align_cornersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier align_cornersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier half_pixel_centersAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier half_pixel_centersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResizeBilinear");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value images();
  ::mlir::Value size();
  ::mlir::MutableOperandRange imagesMutable();
  ::mlir::MutableOperandRange sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value resized_images();
  ::mlir::BoolAttr align_cornersAttr();
  bool align_corners();
  ::mlir::BoolAttr half_pixel_centersAttr();
  bool half_pixel_centers();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void align_cornersAttr(::mlir::BoolAttr attr);
  void half_pixel_centersAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResizeBilinearOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeNearestNeighborGradOp declarations
//===----------------------------------------------------------------------===//

class ResizeNearestNeighborGradOpAdaptor {
public:
  ResizeNearestNeighborGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResizeNearestNeighborGradOpAdaptor(ResizeNearestNeighborGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value grads();
  ::mlir::Value size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr align_corners();
  ::mlir::BoolAttr half_pixel_centers();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResizeNearestNeighborGradOp : public ::mlir::Op<ResizeNearestNeighborGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResizeNearestNeighborGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("align_corners"), ::llvm::StringRef("half_pixel_centers"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier align_cornersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier align_cornersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier half_pixel_centersAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier half_pixel_centersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResizeNearestNeighborGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value grads();
  ::mlir::Value size();
  ::mlir::MutableOperandRange gradsMutable();
  ::mlir::MutableOperandRange sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr align_cornersAttr();
  bool align_corners();
  ::mlir::BoolAttr half_pixel_centersAttr();
  bool half_pixel_centers();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void align_cornersAttr(::mlir::BoolAttr attr);
  void half_pixel_centersAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value size, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value size, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResizeNearestNeighborGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeNearestNeighborOp declarations
//===----------------------------------------------------------------------===//

class ResizeNearestNeighborOpAdaptor {
public:
  ResizeNearestNeighborOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResizeNearestNeighborOpAdaptor(ResizeNearestNeighborOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value images();
  ::mlir::Value size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr align_corners();
  ::mlir::BoolAttr half_pixel_centers();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResizeNearestNeighborOp : public ::mlir::Op<ResizeNearestNeighborOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResizeNearestNeighborOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("align_corners"), ::llvm::StringRef("half_pixel_centers"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier align_cornersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier align_cornersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier half_pixel_centersAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier half_pixel_centersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResizeNearestNeighbor");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value images();
  ::mlir::Value size();
  ::mlir::MutableOperandRange imagesMutable();
  ::mlir::MutableOperandRange sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value resized_images();
  ::mlir::BoolAttr align_cornersAttr();
  bool align_corners();
  ::mlir::BoolAttr half_pixel_centersAttr();
  bool half_pixel_centers();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void align_cornersAttr(::mlir::BoolAttr attr);
  void half_pixel_centersAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, bool align_corners = false, bool half_pixel_centers = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResizeNearestNeighborOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdaMaxOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyAdaMaxOpAdaptor {
public:
  ResourceApplyAdaMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyAdaMaxOpAdaptor(ResourceApplyAdaMaxOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value v();
  ::mlir::Value beta1_power();
  ::mlir::Value lr();
  ::mlir::Value beta1();
  ::mlir::Value beta2();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyAdaMaxOp : public ::mlir::Op<ResourceApplyAdaMaxOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<9>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyAdaMaxOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyAdaMax");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value v();
  ::mlir::Value beta1_power();
  ::mlir::Value lr();
  ::mlir::Value beta1();
  ::mlir::Value beta2();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange mMutable();
  ::mlir::MutableOperandRange vMutable();
  ::mlir::MutableOperandRange beta1_powerMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange beta1Mutable();
  ::mlir::MutableOperandRange beta2Mutable();
  ::mlir::MutableOperandRange epsilonMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyAdaMaxOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdadeltaOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyAdadeltaOpAdaptor {
public:
  ResourceApplyAdadeltaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyAdadeltaOpAdaptor(ResourceApplyAdadeltaOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value accum_update();
  ::mlir::Value lr();
  ::mlir::Value rho();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyAdadeltaOp : public ::mlir::Op<ResourceApplyAdadeltaOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<7>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyAdadeltaOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyAdadelta");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value accum_update();
  ::mlir::Value lr();
  ::mlir::Value rho();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange accum_updateMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange rhoMutable();
  ::mlir::MutableOperandRange epsilonMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyAdadeltaOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdagradDAOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyAdagradDAOpAdaptor {
public:
  ResourceApplyAdagradDAOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyAdagradDAOpAdaptor(ResourceApplyAdagradDAOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value gradient_accumulator();
  ::mlir::Value gradient_squared_accumulator();
  ::mlir::Value grad();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value global_step();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyAdagradDAOp : public ::mlir::Op<ResourceApplyAdagradDAOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<8>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyAdagradDAOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyAdagradDA");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value gradient_accumulator();
  ::mlir::Value gradient_squared_accumulator();
  ::mlir::Value grad();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value global_step();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange gradient_accumulatorMutable();
  ::mlir::MutableOperandRange gradient_squared_accumulatorMutable();
  ::mlir::MutableOperandRange gradMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange l1Mutable();
  ::mlir::MutableOperandRange l2Mutable();
  ::mlir::MutableOperandRange global_stepMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyAdagradDAOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdagradOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyAdagradOpAdaptor {
public:
  ResourceApplyAdagradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyAdagradOpAdaptor(ResourceApplyAdagradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::BoolAttr update_slots();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyAdagradOp : public ::mlir::Op<ResourceApplyAdagradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyAdagradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("update_slots"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier update_slotsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier update_slotsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyAdagrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::BoolAttr update_slotsAttr();
  bool update_slots();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  void update_slotsAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, bool use_locking = false, bool update_slots = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, bool use_locking = false, bool update_slots = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyAdagradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdagradV2Op declarations
//===----------------------------------------------------------------------===//

class ResourceApplyAdagradV2OpAdaptor {
public:
  ResourceApplyAdagradV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyAdagradV2OpAdaptor(ResourceApplyAdagradV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::BoolAttr update_slots();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyAdagradV2Op : public ::mlir::Op<ResourceApplyAdagradV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyAdagradV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("update_slots"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier update_slotsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier update_slotsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyAdagradV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange epsilonMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::BoolAttr update_slotsAttr();
  bool update_slots();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  void update_slotsAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false, bool update_slots = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false, bool update_slots = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyAdagradV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdamOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyAdamOpAdaptor {
public:
  ResourceApplyAdamOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyAdamOpAdaptor(ResourceApplyAdamOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value v();
  ::mlir::Value beta1_power();
  ::mlir::Value beta2_power();
  ::mlir::Value lr();
  ::mlir::Value beta1();
  ::mlir::Value beta2();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::BoolAttr use_nesterov();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyAdamOp : public ::mlir::Op<ResourceApplyAdamOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<10>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyAdamOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("use_nesterov"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier use_nesterovAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier use_nesterovAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyAdam");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value v();
  ::mlir::Value beta1_power();
  ::mlir::Value beta2_power();
  ::mlir::Value lr();
  ::mlir::Value beta1();
  ::mlir::Value beta2();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange mMutable();
  ::mlir::MutableOperandRange vMutable();
  ::mlir::MutableOperandRange beta1_powerMutable();
  ::mlir::MutableOperandRange beta2_powerMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange beta1Mutable();
  ::mlir::MutableOperandRange beta2Mutable();
  ::mlir::MutableOperandRange epsilonMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::BoolAttr use_nesterovAttr();
  bool use_nesterov();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  void use_nesterovAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false, bool use_nesterov = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false, bool use_nesterov = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyAdamOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAddSignOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyAddSignOpAdaptor {
public:
  ResourceApplyAddSignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyAddSignOpAdaptor(ResourceApplyAddSignOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value lr();
  ::mlir::Value alpha();
  ::mlir::Value sign_decay();
  ::mlir::Value beta();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyAddSignOp : public ::mlir::Op<ResourceApplyAddSignOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<7>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyAddSignOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyAddSign");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value lr();
  ::mlir::Value alpha();
  ::mlir::Value sign_decay();
  ::mlir::Value beta();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange mMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange alphaMutable();
  ::mlir::MutableOperandRange sign_decayMutable();
  ::mlir::MutableOperandRange betaMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyAddSignOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyCenteredRMSPropOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyCenteredRMSPropOpAdaptor {
public:
  ResourceApplyCenteredRMSPropOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyCenteredRMSPropOpAdaptor(ResourceApplyCenteredRMSPropOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value mg();
  ::mlir::Value ms();
  ::mlir::Value mom();
  ::mlir::Value lr();
  ::mlir::Value rho();
  ::mlir::Value momentum();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyCenteredRMSPropOp : public ::mlir::Op<ResourceApplyCenteredRMSPropOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<9>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyCenteredRMSPropOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyCenteredRMSProp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value mg();
  ::mlir::Value ms();
  ::mlir::Value mom();
  ::mlir::Value lr();
  ::mlir::Value rho();
  ::mlir::Value momentum();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange mgMutable();
  ::mlir::MutableOperandRange msMutable();
  ::mlir::MutableOperandRange momMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange rhoMutable();
  ::mlir::MutableOperandRange momentumMutable();
  ::mlir::MutableOperandRange epsilonMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyCenteredRMSPropOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyFtrlOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyFtrlOpAdaptor {
public:
  ResourceApplyFtrlOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyFtrlOpAdaptor(ResourceApplyFtrlOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value linear();
  ::mlir::Value grad();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value lr_power();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::BoolAttr multiply_linear_by_lr();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyFtrlOp : public ::mlir::Op<ResourceApplyFtrlOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<8>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyFtrlOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("multiply_linear_by_lr"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier multiply_linear_by_lrAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier multiply_linear_by_lrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyFtrl");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value linear();
  ::mlir::Value grad();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value lr_power();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange linearMutable();
  ::mlir::MutableOperandRange gradMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange l1Mutable();
  ::mlir::MutableOperandRange l2Mutable();
  ::mlir::MutableOperandRange lr_powerMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::BoolAttr multiply_linear_by_lrAttr();
  bool multiply_linear_by_lr();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  void multiply_linear_by_lrAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, bool use_locking = false, bool multiply_linear_by_lr = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, bool use_locking = false, bool multiply_linear_by_lr = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyFtrlOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyFtrlV2Op declarations
//===----------------------------------------------------------------------===//

class ResourceApplyFtrlV2OpAdaptor {
public:
  ResourceApplyFtrlV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyFtrlV2OpAdaptor(ResourceApplyFtrlV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value linear();
  ::mlir::Value grad();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value l2_shrinkage();
  ::mlir::Value lr_power();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::BoolAttr multiply_linear_by_lr();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyFtrlV2Op : public ::mlir::Op<ResourceApplyFtrlV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<9>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyFtrlV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("multiply_linear_by_lr"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier multiply_linear_by_lrAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier multiply_linear_by_lrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyFtrlV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value linear();
  ::mlir::Value grad();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value l2_shrinkage();
  ::mlir::Value lr_power();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange linearMutable();
  ::mlir::MutableOperandRange gradMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange l1Mutable();
  ::mlir::MutableOperandRange l2Mutable();
  ::mlir::MutableOperandRange l2_shrinkageMutable();
  ::mlir::MutableOperandRange lr_powerMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::BoolAttr multiply_linear_by_lrAttr();
  bool multiply_linear_by_lr();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  void multiply_linear_by_lrAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, bool use_locking = false, bool multiply_linear_by_lr = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, bool use_locking = false, bool multiply_linear_by_lr = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyFtrlV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyGradientDescentOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyGradientDescentOpAdaptor {
public:
  ResourceApplyGradientDescentOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyGradientDescentOpAdaptor(ResourceApplyGradientDescentOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value alpha();
  ::mlir::Value delta();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyGradientDescentOp : public ::mlir::Op<ResourceApplyGradientDescentOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyGradientDescentOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyGradientDescent");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value alpha();
  ::mlir::Value delta();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange alphaMutable();
  ::mlir::MutableOperandRange deltaMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyGradientDescentOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyKerasMomentumOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyKerasMomentumOpAdaptor {
public:
  ResourceApplyKerasMomentumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyKerasMomentumOpAdaptor(ResourceApplyKerasMomentumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value grad();
  ::mlir::Value momentum();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::BoolAttr use_nesterov();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyKerasMomentumOp : public ::mlir::Op<ResourceApplyKerasMomentumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyKerasMomentumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("use_nesterov"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier use_nesterovAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier use_nesterovAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyKerasMomentum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value grad();
  ::mlir::Value momentum();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange gradMutable();
  ::mlir::MutableOperandRange momentumMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::BoolAttr use_nesterovAttr();
  bool use_nesterov();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  void use_nesterovAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking = false, bool use_nesterov = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking = false, bool use_nesterov = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyKerasMomentumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyMomentumOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyMomentumOpAdaptor {
public:
  ResourceApplyMomentumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyMomentumOpAdaptor(ResourceApplyMomentumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value grad();
  ::mlir::Value momentum();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::BoolAttr use_nesterov();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyMomentumOp : public ::mlir::Op<ResourceApplyMomentumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyMomentumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("use_nesterov"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier use_nesterovAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier use_nesterovAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyMomentum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value grad();
  ::mlir::Value momentum();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange gradMutable();
  ::mlir::MutableOperandRange momentumMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::BoolAttr use_nesterovAttr();
  bool use_nesterov();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  void use_nesterovAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking = false, bool use_nesterov = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking = false, bool use_nesterov = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyMomentumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyPowerSignOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyPowerSignOpAdaptor {
public:
  ResourceApplyPowerSignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyPowerSignOpAdaptor(ResourceApplyPowerSignOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value lr();
  ::mlir::Value logbase();
  ::mlir::Value sign_decay();
  ::mlir::Value beta();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyPowerSignOp : public ::mlir::Op<ResourceApplyPowerSignOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<7>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyPowerSignOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyPowerSign");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value m();
  ::mlir::Value lr();
  ::mlir::Value logbase();
  ::mlir::Value sign_decay();
  ::mlir::Value beta();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange mMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange logbaseMutable();
  ::mlir::MutableOperandRange sign_decayMutable();
  ::mlir::MutableOperandRange betaMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyPowerSignOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyProximalAdagradOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyProximalAdagradOpAdaptor {
public:
  ResourceApplyProximalAdagradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyProximalAdagradOpAdaptor(ResourceApplyProximalAdagradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyProximalAdagradOp : public ::mlir::Op<ResourceApplyProximalAdagradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<6>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyProximalAdagradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyProximalAdagrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value accum();
  ::mlir::Value lr();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange accumMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange l1Mutable();
  ::mlir::MutableOperandRange l2Mutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyProximalAdagradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyProximalGradientDescentOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyProximalGradientDescentOpAdaptor {
public:
  ResourceApplyProximalGradientDescentOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyProximalGradientDescentOpAdaptor(ResourceApplyProximalGradientDescentOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value alpha();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value delta();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyProximalGradientDescentOp : public ::mlir::Op<ResourceApplyProximalGradientDescentOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyProximalGradientDescentOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyProximalGradientDescent");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value alpha();
  ::mlir::Value l1();
  ::mlir::Value l2();
  ::mlir::Value delta();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange alphaMutable();
  ::mlir::MutableOperandRange l1Mutable();
  ::mlir::MutableOperandRange l2Mutable();
  ::mlir::MutableOperandRange deltaMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyProximalGradientDescentOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyRMSPropOp declarations
//===----------------------------------------------------------------------===//

class ResourceApplyRMSPropOpAdaptor {
public:
  ResourceApplyRMSPropOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceApplyRMSPropOpAdaptor(ResourceApplyRMSPropOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value ms();
  ::mlir::Value mom();
  ::mlir::Value lr();
  ::mlir::Value rho();
  ::mlir::Value momentum();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceApplyRMSPropOp : public ::mlir::Op<ResourceApplyRMSPropOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<8>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceApplyRMSPropOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceApplyRMSProp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value var();
  ::mlir::Value ms();
  ::mlir::Value mom();
  ::mlir::Value lr();
  ::mlir::Value rho();
  ::mlir::Value momentum();
  ::mlir::Value epsilon();
  ::mlir::Value grad();
  ::mlir::MutableOperandRange varMutable();
  ::mlir::MutableOperandRange msMutable();
  ::mlir::MutableOperandRange momMutable();
  ::mlir::MutableOperandRange lrMutable();
  ::mlir::MutableOperandRange rhoMutable();
  ::mlir::MutableOperandRange momentumMutable();
  ::mlir::MutableOperandRange epsilonMutable();
  ::mlir::MutableOperandRange gradMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceApplyRMSPropOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceGatherOp declarations
//===----------------------------------------------------------------------===//

class ResourceGatherOpAdaptor {
public:
  ResourceGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceGatherOpAdaptor(ResourceGatherOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr batch_dims();
  ::mlir::BoolAttr validate_indices();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceGatherOp : public ::mlir::Op<ResourceGatherOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceGatherOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_dims"), ::llvm::StringRef("validate_indices"), ::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier batch_dimsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier batch_dimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier validate_indicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier validate_indicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceGather");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr batch_dimsAttr();
  uint64_t batch_dims();
  ::mlir::BoolAttr validate_indicesAttr();
  bool validate_indices();
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void batch_dimsAttr(::mlir::IntegerAttr attr);
  void validate_indicesAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value indices, ::mlir::IntegerAttr batch_dims, ::mlir::BoolAttr validate_indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::IntegerAttr batch_dims, ::mlir::BoolAttr validate_indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value indices, uint64_t batch_dims = 0, bool validate_indices = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, uint64_t batch_dims = 0, bool validate_indices = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceGatherOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterAddOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterAddOpAdaptor {
public:
  ResourceScatterAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterAddOpAdaptor(ResourceScatterAddOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterAddOp : public ::mlir::Op<ResourceScatterAddOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterAddOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterAdd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterAddOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterDivOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterDivOpAdaptor {
public:
  ResourceScatterDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterDivOpAdaptor(ResourceScatterDivOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterDivOp : public ::mlir::Op<ResourceScatterDivOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterDivOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterDiv");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterDivOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterMaxOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterMaxOpAdaptor {
public:
  ResourceScatterMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterMaxOpAdaptor(ResourceScatterMaxOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterMaxOp : public ::mlir::Op<ResourceScatterMaxOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterMaxOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterMax");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterMaxOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterMinOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterMinOpAdaptor {
public:
  ResourceScatterMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterMinOpAdaptor(ResourceScatterMinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterMinOp : public ::mlir::Op<ResourceScatterMinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterMinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterMin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterMinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterMulOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterMulOpAdaptor {
public:
  ResourceScatterMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterMulOpAdaptor(ResourceScatterMulOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterMulOp : public ::mlir::Op<ResourceScatterMulOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterMulOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterMul");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterMulOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterNdAddOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterNdAddOpAdaptor {
public:
  ResourceScatterNdAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterNdAddOpAdaptor(ResourceScatterNdAddOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterNdAddOp : public ::mlir::Op<ResourceScatterNdAddOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterNdAddOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterNdAdd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange refMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterNdAddOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterNdSubOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterNdSubOpAdaptor {
public:
  ResourceScatterNdSubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterNdSubOpAdaptor(ResourceScatterNdSubOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterNdSubOp : public ::mlir::Op<ResourceScatterNdSubOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterNdSubOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterNdSub");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange refMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterNdSubOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterNdUpdateOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterNdUpdateOpAdaptor {
public:
  ResourceScatterNdUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterNdUpdateOpAdaptor(ResourceScatterNdUpdateOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr use_locking();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterNdUpdateOp : public ::mlir::Op<ResourceScatterNdUpdateOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterNdUpdateOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("use_locking"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier use_lockingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier use_lockingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterNdUpdate");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange refMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::BoolAttr use_lockingAttr();
  bool use_locking();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void use_lockingAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterNdUpdateOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterSubOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterSubOpAdaptor {
public:
  ResourceScatterSubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterSubOpAdaptor(ResourceScatterSubOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterSubOp : public ::mlir::Op<ResourceScatterSubOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterSubOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterSub");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterSubOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterUpdateOp declarations
//===----------------------------------------------------------------------===//

class ResourceScatterUpdateOpAdaptor {
public:
  ResourceScatterUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceScatterUpdateOpAdaptor(ResourceScatterUpdateOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceScatterUpdateOp : public ::mlir::Op<ResourceScatterUpdateOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceScatterUpdateOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tindices"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceScatterUpdate");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type Tindices();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceScatterUpdateOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceStridedSliceAssignOp declarations
//===----------------------------------------------------------------------===//

class ResourceStridedSliceAssignOpAdaptor {
public:
  ResourceStridedSliceAssignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ResourceStridedSliceAssignOpAdaptor(ResourceStridedSliceAssignOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::Value value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr begin_mask();
  ::mlir::IntegerAttr end_mask();
  ::mlir::IntegerAttr ellipsis_mask();
  ::mlir::IntegerAttr new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_mask();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ResourceStridedSliceAssignOp : public ::mlir::Op<ResourceStridedSliceAssignOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ResourceStridedSliceAssignOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("begin_mask"), ::llvm::StringRef("end_mask"), ::llvm::StringRef("ellipsis_mask"), ::llvm::StringRef("new_axis_mask"), ::llvm::StringRef("shrink_axis_mask"), ::llvm::StringRef("Index"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier begin_maskAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier begin_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier end_maskAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier end_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier ellipsis_maskAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier ellipsis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier new_axis_maskAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier new_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier shrink_axis_maskAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier shrink_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier IndexAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier IndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ResourceStridedSliceAssign");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value ref();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::Value value();
  ::mlir::MutableOperandRange refMutable();
  ::mlir::MutableOperandRange beginMutable();
  ::mlir::MutableOperandRange endMutable();
  ::mlir::MutableOperandRange stridesMutable();
  ::mlir::MutableOperandRange valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::IntegerAttr begin_maskAttr();
  uint64_t begin_mask();
  ::mlir::IntegerAttr end_maskAttr();
  uint64_t end_mask();
  ::mlir::IntegerAttr ellipsis_maskAttr();
  uint64_t ellipsis_mask();
  ::mlir::IntegerAttr new_axis_maskAttr();
  uint64_t new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_maskAttr();
  uint64_t shrink_axis_mask();
  ::mlir::Type Index();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void begin_maskAttr(::mlir::IntegerAttr attr);
  void end_maskAttr(::mlir::IntegerAttr attr);
  void ellipsis_maskAttr(::mlir::IntegerAttr attr);
  void new_axis_maskAttr(::mlir::IntegerAttr attr);
  void shrink_axis_maskAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ResourceStridedSliceAssignOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RestoreOp declarations
//===----------------------------------------------------------------------===//

class RestoreOpAdaptor {
public:
  RestoreOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RestoreOpAdaptor(RestoreOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value file_pattern();
  ::mlir::Value tensor_name();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr preferred_shard();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RestoreOp : public ::mlir::Op<RestoreOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RestoreOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("preferred_shard"), ::llvm::StringRef("dt")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier preferred_shardAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier preferred_shardAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Restore");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value file_pattern();
  ::mlir::Value tensor_name();
  ::mlir::MutableOperandRange file_patternMutable();
  ::mlir::MutableOperandRange tensor_nameMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value tensor();
  ::mlir::IntegerAttr preferred_shardAttr();
  uint64_t preferred_shard();
  ::mlir::Type dt();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void preferred_shardAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Value file_pattern, ::mlir::Value tensor_name, ::mlir::IntegerAttr preferred_shard);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value file_pattern, ::mlir::Value tensor_name, ::mlir::IntegerAttr preferred_shard);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Value file_pattern, ::mlir::Value tensor_name, uint64_t preferred_shard = -1);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value file_pattern, ::mlir::Value tensor_name, uint64_t preferred_shard = -1);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RestoreOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RestoreV2Op declarations
//===----------------------------------------------------------------------===//

class RestoreV2OpAdaptor {
public:
  RestoreV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RestoreV2OpAdaptor(RestoreV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value prefix();
  ::mlir::Value tensor_names();
  ::mlir::Value shape_and_slices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RestoreV2Op : public ::mlir::Op<RestoreV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RestoreV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtypes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RestoreV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value prefix();
  ::mlir::Value tensor_names();
  ::mlir::Value shape_and_slices();
  ::mlir::MutableOperandRange prefixMutable();
  ::mlir::MutableOperandRange tensor_namesMutable();
  ::mlir::MutableOperandRange shape_and_slicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range tensors();
  mlir::ResultElementTypeRange dtypes();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange tensors, ::mlir::Value prefix, ::mlir::Value tensor_names, ::mlir::Value shape_and_slices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RestoreV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingADAMParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingADAMParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingADAMParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingADAMParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingADAMParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value momenta();
  ::mlir::Value velocities();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, ::mlir::Type velocities, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, ::mlir::Type velocities, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingADAMParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingADAMParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingADAMParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingADAMParametersOpAdaptor(RetrieveTPUEmbeddingADAMParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingADAMParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingADAMParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingADAMParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingADAMParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value momenta();
  ::mlir::Value velocities();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, ::mlir::Type velocities, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, ::mlir::Type velocities, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingADAMParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::Value updates();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type updates, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type updates, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingAdadeltaParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingAdadeltaParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingAdadeltaParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingAdadeltaParametersOpAdaptor(RetrieveTPUEmbeddingAdadeltaParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingAdadeltaParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingAdadeltaParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingAdadeltaParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingAdadeltaParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::Value updates();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type updates, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type updates, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingAdadeltaParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingAdagradParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingAdagradParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingAdagradParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingAdagradParametersOpAdaptor(RetrieveTPUEmbeddingAdagradParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingAdagradParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingAdagradParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingAdagradParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingAdagradParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingAdagradParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingCenteredRMSPropParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingCenteredRMSPropParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingCenteredRMSPropParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingCenteredRMSPropParametersOpAdaptor(RetrieveTPUEmbeddingCenteredRMSPropParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingCenteredRMSPropParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingCenteredRMSPropParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingCenteredRMSPropParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingCenteredRMSPropParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value ms();
  ::mlir::Value mom();
  ::mlir::Value mg();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type ms, ::mlir::Type mom, ::mlir::Type mg, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type ms, ::mlir::Type mom, ::mlir::Type mg, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingCenteredRMSPropParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::Value linears();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type linears, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type linears, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingFTRLParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingFTRLParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingFTRLParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingFTRLParametersOpAdaptor(RetrieveTPUEmbeddingFTRLParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingFTRLParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingFTRLParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingFTRLParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingFTRLParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::Value linears();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type linears, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type linears, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingFTRLParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingMDLAdagradLightParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingMDLAdagradLightParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingMDLAdagradLightParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingMDLAdagradLightParametersOpAdaptor(RetrieveTPUEmbeddingMDLAdagradLightParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingMDLAdagradLightParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingMDLAdagradLightParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingMDLAdagradLightParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingMDLAdagradLightParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::Value weights();
  ::mlir::Value benefits();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type weights, ::mlir::Type benefits, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type weights, ::mlir::Type benefits, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingMDLAdagradLightParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value momenta();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingMomentumParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingMomentumParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingMomentumParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingMomentumParametersOpAdaptor(RetrieveTPUEmbeddingMomentumParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingMomentumParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingMomentumParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingMomentumParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingMomentumParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value momenta();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type momenta, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingMomentumParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingProximalAdagradParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingProximalAdagradParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingProximalAdagradParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingProximalAdagradParametersOpAdaptor(RetrieveTPUEmbeddingProximalAdagradParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingProximalAdagradParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingProximalAdagradParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingProximalAdagradParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingProximalAdagradParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingProximalAdagradParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value v();
  ::mlir::Value m();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type v, ::mlir::Type m, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type v, ::mlir::Type m, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingProximalYogiParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingProximalYogiParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingProximalYogiParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingProximalYogiParametersOpAdaptor(RetrieveTPUEmbeddingProximalYogiParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingProximalYogiParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingProximalYogiParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingProximalYogiParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingProximalYogiParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value v();
  ::mlir::Value m();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type v, ::mlir::Type m, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type v, ::mlir::Type m, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingProximalYogiParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value ms();
  ::mlir::Value mom();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type ms, ::mlir::Type mom, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type ms, ::mlir::Type mom, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingRMSPropParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingRMSPropParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingRMSPropParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingRMSPropParametersOpAdaptor(RetrieveTPUEmbeddingRMSPropParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingRMSPropParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingRMSPropParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingRMSPropParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingRMSPropParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value ms();
  ::mlir::Value mom();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type ms, ::mlir::Type mom, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type ms, ::mlir::Type mom, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingRMSPropParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOpAdaptor {
public:
  RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOpAdaptor(RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOp : public ::mlir::Op<RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::Value gradient_accumulators();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type gradient_accumulators, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::Type gradient_accumulators, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebugOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RetrieveTPUEmbeddingStochasticGradientDescentParametersOp declarations
//===----------------------------------------------------------------------===//

class RetrieveTPUEmbeddingStochasticGradientDescentParametersOpAdaptor {
public:
  RetrieveTPUEmbeddingStochasticGradientDescentParametersOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RetrieveTPUEmbeddingStochasticGradientDescentParametersOpAdaptor(RetrieveTPUEmbeddingStochasticGradientDescentParametersOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::StringAttr table_name();
  ::mlir::IntegerAttr num_shards();
  ::mlir::IntegerAttr shard_id();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RetrieveTPUEmbeddingStochasticGradientDescentParametersOp : public ::mlir::Op<RetrieveTPUEmbeddingStochasticGradientDescentParametersOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RetrieveTPUEmbeddingStochasticGradientDescentParametersOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("table_name"), ::llvm::StringRef("num_shards"), ::llvm::StringRef("shard_id"), ::llvm::StringRef("config")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier table_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier table_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_shardsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_shardsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shard_idAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shard_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RetrieveTPUEmbeddingStochasticGradientDescentParameters");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value parameters();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::StringAttr table_nameAttr();
  ::llvm::StringRef table_name();
  ::mlir::IntegerAttr num_shardsAttr();
  uint64_t num_shards();
  ::mlir::IntegerAttr shard_idAttr();
  uint64_t shard_id();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  void table_idAttr(::mlir::IntegerAttr attr);
  void table_nameAttr(::mlir::StringAttr attr);
  void num_shardsAttr(::mlir::IntegerAttr attr);
  void shard_idAttr(::mlir::IntegerAttr attr);
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr table_id, ::mlir::StringAttr table_name, ::mlir::IntegerAttr num_shards, ::mlir::IntegerAttr shard_id, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type parameters, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t table_id, ::llvm::StringRef table_name, uint64_t num_shards, uint64_t shard_id, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RetrieveTPUEmbeddingStochasticGradientDescentParametersOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReverseOp declarations
//===----------------------------------------------------------------------===//

class ReverseOpAdaptor {
public:
  ReverseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReverseOpAdaptor(ReverseOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value dims();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReverseOp : public ::mlir::Op<ReverseOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReverseOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Reverse");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value dims();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange dimsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value dims);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReverseOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReverseSequenceOp declarations
//===----------------------------------------------------------------------===//

class ReverseSequenceOpAdaptor {
public:
  ReverseSequenceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReverseSequenceOpAdaptor(ReverseSequenceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value seq_lengths();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seq_dim();
  ::mlir::IntegerAttr batch_dim();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReverseSequenceOp : public ::mlir::Op<ReverseSequenceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReverseSequenceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seq_dim"), ::llvm::StringRef("batch_dim"), ::llvm::StringRef("T"), ::llvm::StringRef("Tlen")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seq_dimAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seq_dimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier batch_dimAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier batch_dimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TlenAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TlenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ReverseSequence");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value seq_lengths();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange seq_lengthsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seq_dimAttr();
  uint64_t seq_dim();
  ::mlir::IntegerAttr batch_dimAttr();
  uint64_t batch_dim();
  ::mlir::Type T();
  ::mlir::Type Tlen();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seq_dimAttr(::mlir::IntegerAttr attr);
  void batch_dimAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value seq_lengths, ::mlir::IntegerAttr seq_dim, ::mlir::IntegerAttr batch_dim);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value seq_lengths, ::mlir::IntegerAttr seq_dim, ::mlir::IntegerAttr batch_dim);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value seq_lengths, uint64_t seq_dim, uint64_t batch_dim = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value seq_lengths, uint64_t seq_dim, uint64_t batch_dim = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReverseSequenceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReverseV2Op declarations
//===----------------------------------------------------------------------===//

class ReverseV2OpAdaptor {
public:
  ReverseV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ReverseV2OpAdaptor(ReverseV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value axis();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ReverseV2Op : public ::mlir::Op<ReverseV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReverseV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ReverseV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value axis();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange axisMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value axis);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ReverseV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RightShiftOp declarations
//===----------------------------------------------------------------------===//

class RightShiftOpAdaptor {
public:
  RightShiftOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RightShiftOpAdaptor(RightShiftOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RightShiftOp : public ::mlir::Op<RightShiftOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RightShiftOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RightShift");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RightShiftOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RintOp declarations
//===----------------------------------------------------------------------===//

class RintOpAdaptor {
public:
  RintOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RintOpAdaptor(RintOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RintOp : public ::mlir::Op<RintOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsIdempotent, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RintOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Rint");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RintOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RiscAddOp declarations
//===----------------------------------------------------------------------===//

class RiscAddOpAdaptor {
public:
  RiscAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RiscAddOpAdaptor(RiscAddOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RiscAddOp : public ::mlir::Op<RiscAddOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::IsCommutative, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RiscAddOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RiscAdd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RiscAddOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RiscDotOp declarations
//===----------------------------------------------------------------------===//

class RiscDotOpAdaptor {
public:
  RiscDotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RiscDotOpAdaptor(RiscDotOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value b();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr transpose_a();
  ::mlir::BoolAttr transpose_b();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RiscDotOp : public ::mlir::Op<RiscDotOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RiscDotOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("transpose_a"), ::llvm::StringRef("transpose_b"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier transpose_aAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier transpose_aAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier transpose_bAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier transpose_bAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RiscDot");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value b();
  ::mlir::MutableOperandRange aMutable();
  ::mlir::MutableOperandRange bMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value product();
  ::mlir::BoolAttr transpose_aAttr();
  bool transpose_a();
  ::mlir::BoolAttr transpose_bAttr();
  bool transpose_b();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void transpose_aAttr(::mlir::BoolAttr attr);
  void transpose_bAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, bool transpose_a = false, bool transpose_b = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, bool transpose_a = false, bool transpose_b = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RiscDotOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RngReadAndSkipOp declarations
//===----------------------------------------------------------------------===//

class RngReadAndSkipOpAdaptor {
public:
  RngReadAndSkipOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RngReadAndSkipOpAdaptor(RngReadAndSkipOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value alg();
  ::mlir::Value delta();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RngReadAndSkipOp : public ::mlir::Op<RngReadAndSkipOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RngReadAndSkipOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RngReadAndSkip");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value alg();
  ::mlir::Value delta();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange algMutable();
  ::mlir::MutableOperandRange deltaMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value value();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value resource, ::mlir::Value alg, ::mlir::Value delta);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value alg, ::mlir::Value delta);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RngReadAndSkipOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RollOp declarations
//===----------------------------------------------------------------------===//

class RollOpAdaptor {
public:
  RollOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RollOpAdaptor(RollOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value shift();
  ::mlir::Value axis();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RollOp : public ::mlir::Op<RollOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RollOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Taxis"), ::llvm::StringRef("Tshift")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TaxisAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TaxisAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TshiftAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TshiftAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Roll");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value shift();
  ::mlir::Value axis();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange shiftMutable();
  ::mlir::MutableOperandRange axisMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Taxis();
  ::mlir::Type Tshift();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value shift, ::mlir::Value axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value shift, ::mlir::Value axis);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RollOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RoundOp declarations
//===----------------------------------------------------------------------===//

class RoundOpAdaptor {
public:
  RoundOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RoundOpAdaptor(RoundOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RoundOp : public ::mlir::Op<RoundOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsIdempotent, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RoundOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Round");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RoundOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RsqrtGradOp declarations
//===----------------------------------------------------------------------===//

class RsqrtGradOpAdaptor {
public:
  RsqrtGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RsqrtGradOpAdaptor(RsqrtGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RsqrtGradOp : public ::mlir::Op<RsqrtGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RsqrtGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.RsqrtGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::MutableOperandRange yMutable();
  ::mlir::MutableOperandRange dyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RsqrtGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RsqrtOp declarations
//===----------------------------------------------------------------------===//

class RsqrtOpAdaptor {
public:
  RsqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  RsqrtOpAdaptor(RsqrtOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class RsqrtOp : public ::mlir::Op<RsqrtOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RsqrtOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Rsqrt");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::RsqrtOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SaveOp declarations
//===----------------------------------------------------------------------===//

class SaveOpAdaptor {
public:
  SaveOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SaveOpAdaptor(SaveOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value filename();
  ::mlir::Value tensor_names();
  ::mlir::ValueRange data();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SaveOp : public ::mlir::Op<SaveOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SaveOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Save");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value filename();
  ::mlir::Value tensor_names();
  ::mlir::Operation::operand_range data();
  ::mlir::MutableOperandRange filenameMutable();
  ::mlir::MutableOperandRange tensor_namesMutable();
  ::mlir::MutableOperandRange dataMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  mlir::OperandElementTypeRange T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value filename, ::mlir::Value tensor_names, ::mlir::ValueRange data);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value filename, ::mlir::Value tensor_names, ::mlir::ValueRange data);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SaveOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SaveSlicesOp declarations
//===----------------------------------------------------------------------===//

class SaveSlicesOpAdaptor {
public:
  SaveSlicesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SaveSlicesOpAdaptor(SaveSlicesOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value filename();
  ::mlir::Value tensor_names();
  ::mlir::Value shapes_and_slices();
  ::mlir::ValueRange data();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SaveSlicesOp : public ::mlir::Op<SaveSlicesOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SaveSlicesOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SaveSlices");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value filename();
  ::mlir::Value tensor_names();
  ::mlir::Value shapes_and_slices();
  ::mlir::Operation::operand_range data();
  ::mlir::MutableOperandRange filenameMutable();
  ::mlir::MutableOperandRange tensor_namesMutable();
  ::mlir::MutableOperandRange shapes_and_slicesMutable();
  ::mlir::MutableOperandRange dataMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  mlir::OperandElementTypeRange T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value filename, ::mlir::Value tensor_names, ::mlir::Value shapes_and_slices, ::mlir::ValueRange data);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value filename, ::mlir::Value tensor_names, ::mlir::Value shapes_and_slices, ::mlir::ValueRange data);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SaveSlicesOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SaveV2Op declarations
//===----------------------------------------------------------------------===//

class SaveV2OpAdaptor {
public:
  SaveV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SaveV2OpAdaptor(SaveV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value prefix();
  ::mlir::Value tensor_names();
  ::mlir::Value shape_and_slices();
  ::mlir::ValueRange tensors();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SaveV2Op : public ::mlir::Op<SaveV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SaveV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtypes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SaveV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value prefix();
  ::mlir::Value tensor_names();
  ::mlir::Value shape_and_slices();
  ::mlir::Operation::operand_range tensors();
  ::mlir::MutableOperandRange prefixMutable();
  ::mlir::MutableOperandRange tensor_namesMutable();
  ::mlir::MutableOperandRange shape_and_slicesMutable();
  ::mlir::MutableOperandRange tensorsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  mlir::OperandElementTypeRange dtypes();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value prefix, ::mlir::Value tensor_names, ::mlir::Value shape_and_slices, ::mlir::ValueRange tensors);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value prefix, ::mlir::Value tensor_names, ::mlir::Value shape_and_slices, ::mlir::ValueRange tensors);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SaveV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ScatterNdOp declarations
//===----------------------------------------------------------------------===//

class ScatterNdOpAdaptor {
public:
  ScatterNdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ScatterNdOpAdaptor(ScatterNdOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ScatterNdOp : public ::mlir::Op<ScatterNdOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ScatterNdOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ScatterNd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::Value shape();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value indices, ::mlir::Value updates, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value updates, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ScatterNdOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentMaxOp declarations
//===----------------------------------------------------------------------===//

class SegmentMaxOpAdaptor {
public:
  SegmentMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SegmentMaxOpAdaptor(SegmentMaxOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SegmentMaxOp : public ::mlir::Op<SegmentMaxOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SegmentMaxOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SegmentMax");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SegmentMaxOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentMeanOp declarations
//===----------------------------------------------------------------------===//

class SegmentMeanOpAdaptor {
public:
  SegmentMeanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SegmentMeanOpAdaptor(SegmentMeanOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SegmentMeanOp : public ::mlir::Op<SegmentMeanOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SegmentMeanOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SegmentMean");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SegmentMeanOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentMinOp declarations
//===----------------------------------------------------------------------===//

class SegmentMinOpAdaptor {
public:
  SegmentMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SegmentMinOpAdaptor(SegmentMinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SegmentMinOp : public ::mlir::Op<SegmentMinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SegmentMinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SegmentMin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SegmentMinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentProdOp declarations
//===----------------------------------------------------------------------===//

class SegmentProdOpAdaptor {
public:
  SegmentProdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SegmentProdOpAdaptor(SegmentProdOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SegmentProdOp : public ::mlir::Op<SegmentProdOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SegmentProdOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SegmentProd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SegmentProdOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentSumOp declarations
//===----------------------------------------------------------------------===//

class SegmentSumOpAdaptor {
public:
  SegmentSumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SegmentSumOpAdaptor(SegmentSumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SegmentSumOp : public ::mlir::Op<SegmentSumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SegmentSumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SegmentSum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SegmentSumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SelectOp declarations
//===----------------------------------------------------------------------===//

class SelectOpAdaptor {
public:
  SelectOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SelectOpAdaptor(SelectOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value condition();
  ::mlir::Value t();
  ::mlir::Value e();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SelectOp : public ::mlir::Op<SelectOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SelectOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Select");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value condition();
  ::mlir::Value t();
  ::mlir::Value e();
  ::mlir::MutableOperandRange conditionMutable();
  ::mlir::MutableOperandRange tMutable();
  ::mlir::MutableOperandRange eMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SelectOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SelectV2Op declarations
//===----------------------------------------------------------------------===//

class SelectV2OpAdaptor {
public:
  SelectV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SelectV2OpAdaptor(SelectV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value condition();
  ::mlir::Value t();
  ::mlir::Value e();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SelectV2Op : public ::mlir::Op<SelectV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SelectV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SelectV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value condition();
  ::mlir::Value t();
  ::mlir::Value e();
  ::mlir::MutableOperandRange conditionMutable();
  ::mlir::MutableOperandRange tMutable();
  ::mlir::MutableOperandRange eMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value condition, Value e, Value t);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SelectV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SelfAdjointEigV2Op declarations
//===----------------------------------------------------------------------===//

class SelfAdjointEigV2OpAdaptor {
public:
  SelfAdjointEigV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SelfAdjointEigV2OpAdaptor(SelfAdjointEigV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr compute_v();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SelfAdjointEigV2Op : public ::mlir::Op<SelfAdjointEigV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SelfAdjointEigV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("compute_v"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier compute_vAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier compute_vAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SelfAdjointEigV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value e();
  ::mlir::Value v();
  ::mlir::BoolAttr compute_vAttr();
  bool compute_v();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void compute_vAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type e, ::mlir::Type v, ::mlir::Value input, ::mlir::BoolAttr compute_v);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr compute_v);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type e, ::mlir::Type v, ::mlir::Value input, bool compute_v = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool compute_v = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SelfAdjointEigV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SeluGradOp declarations
//===----------------------------------------------------------------------===//

class SeluGradOpAdaptor {
public:
  SeluGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SeluGradOpAdaptor(SeluGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value outputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SeluGradOp : public ::mlir::Op<SeluGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SeluGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SeluGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value outputs();
  ::mlir::MutableOperandRange gradientsMutable();
  ::mlir::MutableOperandRange outputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value backprops();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value outputs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value outputs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SeluGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SeluOp declarations
//===----------------------------------------------------------------------===//

class SeluOpAdaptor {
public:
  SeluOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SeluOpAdaptor(SeluOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SeluOp : public ::mlir::Op<SeluOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SeluOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Selu");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value activations();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SeluOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SendOp declarations
//===----------------------------------------------------------------------===//

class SendOpAdaptor {
public:
  SendOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SendOpAdaptor(SendOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr tensor_name();
  ::mlir::StringAttr send_device();
  ::mlir::IntegerAttr send_device_incarnation();
  ::mlir::StringAttr recv_device();
  ::mlir::BoolAttr client_terminated();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SendOp : public ::mlir::Op<SendOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SendOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("tensor_name"), ::llvm::StringRef("send_device"), ::llvm::StringRef("send_device_incarnation"), ::llvm::StringRef("recv_device"), ::llvm::StringRef("client_terminated"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier tensor_nameAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier tensor_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier send_deviceAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier send_deviceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier send_device_incarnationAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier send_device_incarnationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier recv_deviceAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier recv_deviceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier client_terminatedAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier client_terminatedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Send");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::MutableOperandRange tensorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::StringAttr tensor_nameAttr();
  ::llvm::StringRef tensor_name();
  ::mlir::StringAttr send_deviceAttr();
  ::llvm::StringRef send_device();
  ::mlir::IntegerAttr send_device_incarnationAttr();
  uint64_t send_device_incarnation();
  ::mlir::StringAttr recv_deviceAttr();
  ::llvm::StringRef recv_device();
  ::mlir::BoolAttr client_terminatedAttr();
  bool client_terminated();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void tensor_nameAttr(::mlir::StringAttr attr);
  void send_deviceAttr(::mlir::StringAttr attr);
  void send_device_incarnationAttr(::mlir::IntegerAttr attr);
  void recv_deviceAttr(::mlir::StringAttr attr);
  void client_terminatedAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value tensor, ::mlir::StringAttr tensor_name, ::mlir::StringAttr send_device, ::mlir::IntegerAttr send_device_incarnation, ::mlir::StringAttr recv_device, ::mlir::BoolAttr client_terminated);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::StringAttr tensor_name, ::mlir::StringAttr send_device, ::mlir::IntegerAttr send_device_incarnation, ::mlir::StringAttr recv_device, ::mlir::BoolAttr client_terminated);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value tensor, ::llvm::StringRef tensor_name, ::llvm::StringRef send_device, uint64_t send_device_incarnation, ::llvm::StringRef recv_device, bool client_terminated = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::llvm::StringRef tensor_name, ::llvm::StringRef send_device, uint64_t send_device_incarnation, ::llvm::StringRef recv_device, bool client_terminated = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SendOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SendTPUEmbeddingGradientsOp declarations
//===----------------------------------------------------------------------===//

class SendTPUEmbeddingGradientsOpAdaptor {
public:
  SendTPUEmbeddingGradientsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions = {});
  SendTPUEmbeddingGradientsOpAdaptor(SendTPUEmbeddingGradientsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::ValueRange learning_rates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SendTPUEmbeddingGradientsOp : public ::mlir::Op<SendTPUEmbeddingGradientsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SendTPUEmbeddingGradientsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("config"), ::llvm::StringRef("N"), ::llvm::StringRef("NN"), ::llvm::StringRef("operand_segment_sizes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier NNAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier NNAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier operand_segment_sizesAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier operand_segment_sizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SendTPUEmbeddingGradients");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::Operation::operand_range learning_rates();
  ::mlir::MutableOperandRange inputsMutable();
  ::mlir::MutableOperandRange learning_ratesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  size_t N();
  size_t NN();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::mlir::StringAttr config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::llvm::StringRef config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SendTPUEmbeddingGradientsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SerializeIteratorOp declarations
//===----------------------------------------------------------------------===//

class SerializeIteratorOpAdaptor {
public:
  SerializeIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SerializeIteratorOpAdaptor(SerializeIteratorOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource_handle();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr external_state_policy();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SerializeIteratorOp : public ::mlir::Op<SerializeIteratorOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SerializeIteratorOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("external_state_policy")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier external_state_policyAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier external_state_policyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SerializeIterator");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource_handle();
  ::mlir::MutableOperandRange resource_handleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value serialized();
  ::mlir::IntegerAttr external_state_policyAttr();
  uint64_t external_state_policy();
  void external_state_policyAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type serialized, ::mlir::Value resource_handle, ::mlir::IntegerAttr external_state_policy);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource_handle, ::mlir::IntegerAttr external_state_policy);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type serialized, ::mlir::Value resource_handle, uint64_t external_state_policy = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource_handle, uint64_t external_state_policy = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SerializeIteratorOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SerializeSparseOp declarations
//===----------------------------------------------------------------------===//

class SerializeSparseOpAdaptor {
public:
  SerializeSparseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SerializeSparseOpAdaptor(SerializeSparseOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value sparse_indices();
  ::mlir::Value sparse_values();
  ::mlir::Value sparse_shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SerializeSparseOp : public ::mlir::Op<SerializeSparseOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SerializeSparseOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("out_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier out_typeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier out_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SerializeSparse");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value sparse_indices();
  ::mlir::Value sparse_values();
  ::mlir::Value sparse_shape();
  ::mlir::MutableOperandRange sparse_indicesMutable();
  ::mlir::MutableOperandRange sparse_valuesMutable();
  ::mlir::MutableOperandRange sparse_shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value serialized_sparse();
  ::mlir::Type T();
  ::mlir::Type out_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type serialized_sparse, ::mlir::Value sparse_indices, ::mlir::Value sparse_values, ::mlir::Value sparse_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sparse_indices, ::mlir::Value sparse_values, ::mlir::Value sparse_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SerializeSparseOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShapeNOp declarations
//===----------------------------------------------------------------------===//

class ShapeNOpAdaptor {
public:
  ShapeNOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShapeNOpAdaptor(ShapeNOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShapeNOp : public ::mlir::Op<ShapeNOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShapeNOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("N"), ::llvm::StringRef("T"), ::llvm::StringRef("out_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier out_typeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier out_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ShapeN");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  size_t N();
  ::mlir::Type T();
  ::mlir::Type out_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShapeNOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShapeOp declarations
//===----------------------------------------------------------------------===//

class ShapeOpAdaptor {
public:
  ShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShapeOpAdaptor(ShapeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShapeOp : public ::mlir::Op<ShapeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShapeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("out_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier out_typeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier out_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Shape");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type out_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value input, BoolAttr use32Bit);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShapeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShardedFilenameOp declarations
//===----------------------------------------------------------------------===//

class ShardedFilenameOpAdaptor {
public:
  ShardedFilenameOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShardedFilenameOpAdaptor(ShardedFilenameOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value basename();
  ::mlir::Value shard();
  ::mlir::Value num_shards();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShardedFilenameOp : public ::mlir::Op<ShardedFilenameOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShardedFilenameOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ShardedFilename");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value basename();
  ::mlir::Value shard();
  ::mlir::Value num_shards();
  ::mlir::MutableOperandRange basenameMutable();
  ::mlir::MutableOperandRange shardMutable();
  ::mlir::MutableOperandRange num_shardsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value filename();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type filename, ::mlir::Value basename, ::mlir::Value shard, ::mlir::Value num_shards);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value basename, ::mlir::Value shard, ::mlir::Value num_shards);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShardedFilenameOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShuffleAndRepeatDatasetV2Op declarations
//===----------------------------------------------------------------------===//

class ShuffleAndRepeatDatasetV2OpAdaptor {
public:
  ShuffleAndRepeatDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShuffleAndRepeatDatasetV2OpAdaptor(ShuffleAndRepeatDatasetV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::Value seed();
  ::mlir::Value seed2();
  ::mlir::Value count();
  ::mlir::Value seed_generator();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr reshuffle_each_iteration();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShuffleAndRepeatDatasetV2Op : public ::mlir::Op<ShuffleAndRepeatDatasetV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<6>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShuffleAndRepeatDatasetV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("reshuffle_each_iteration"), ::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier reshuffle_each_iterationAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier reshuffle_each_iterationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ShuffleAndRepeatDatasetV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::Value seed();
  ::mlir::Value seed2();
  ::mlir::Value count();
  ::mlir::Value seed_generator();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange buffer_sizeMutable();
  ::mlir::MutableOperandRange seedMutable();
  ::mlir::MutableOperandRange seed2Mutable();
  ::mlir::MutableOperandRange countMutable();
  ::mlir::MutableOperandRange seed_generatorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::BoolAttr reshuffle_each_iterationAttr();
  bool reshuffle_each_iteration();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  void reshuffle_each_iterationAttr(::mlir::BoolAttr attr);
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShuffleAndRepeatDatasetV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShuffleDatasetV2Op declarations
//===----------------------------------------------------------------------===//

class ShuffleDatasetV2OpAdaptor {
public:
  ShuffleDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShuffleDatasetV2OpAdaptor(ShuffleDatasetV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::Value seed_generator();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShuffleDatasetV2Op : public ::mlir::Op<ShuffleDatasetV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShuffleDatasetV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ShuffleDatasetV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::Value seed_generator();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange buffer_sizeMutable();
  ::mlir::MutableOperandRange seed_generatorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed_generator, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed_generator, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShuffleDatasetV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShuffleDatasetV3Op declarations
//===----------------------------------------------------------------------===//

class ShuffleDatasetV3OpAdaptor {
public:
  ShuffleDatasetV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShuffleDatasetV3OpAdaptor(ShuffleDatasetV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::Value seed();
  ::mlir::Value seed2();
  ::mlir::Value seed_generator();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr reshuffle_each_iteration();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShuffleDatasetV3Op : public ::mlir::Op<ShuffleDatasetV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShuffleDatasetV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("reshuffle_each_iteration"), ::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier reshuffle_each_iterationAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier reshuffle_each_iterationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ShuffleDatasetV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value buffer_size();
  ::mlir::Value seed();
  ::mlir::Value seed2();
  ::mlir::Value seed_generator();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange buffer_sizeMutable();
  ::mlir::MutableOperandRange seedMutable();
  ::mlir::MutableOperandRange seed2Mutable();
  ::mlir::MutableOperandRange seed_generatorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::BoolAttr reshuffle_each_iterationAttr();
  bool reshuffle_each_iteration();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  void reshuffle_each_iterationAttr(::mlir::BoolAttr attr);
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShuffleDatasetV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShutdownDistributedTPUOp declarations
//===----------------------------------------------------------------------===//

class ShutdownDistributedTPUOpAdaptor {
public:
  ShutdownDistributedTPUOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShutdownDistributedTPUOpAdaptor(ShutdownDistributedTPUOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShutdownDistributedTPUOp : public ::mlir::Op<ShutdownDistributedTPUOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShutdownDistributedTPUOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ShutdownDistributedTPU");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShutdownDistributedTPUOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShutdownTPUSystemOp declarations
//===----------------------------------------------------------------------===//

class ShutdownTPUSystemOpAdaptor {
public:
  ShutdownTPUSystemOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ShutdownTPUSystemOpAdaptor(ShutdownTPUSystemOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ShutdownTPUSystemOp : public ::mlir::Op<ShutdownTPUSystemOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShutdownTPUSystemOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ShutdownTPUSystem");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value success();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type success);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ShutdownTPUSystemOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SigmoidGradOp declarations
//===----------------------------------------------------------------------===//

class SigmoidGradOpAdaptor {
public:
  SigmoidGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SigmoidGradOpAdaptor(SigmoidGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SigmoidGradOp : public ::mlir::Op<SigmoidGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SigmoidGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SigmoidGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::MutableOperandRange yMutable();
  ::mlir::MutableOperandRange dyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SigmoidGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SigmoidOp declarations
//===----------------------------------------------------------------------===//

class SigmoidOpAdaptor {
public:
  SigmoidOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SigmoidOpAdaptor(SigmoidOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SigmoidOp : public ::mlir::Op<SigmoidOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SigmoidOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Sigmoid");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SigmoidOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SignOp declarations
//===----------------------------------------------------------------------===//

class SignOpAdaptor {
public:
  SignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SignOpAdaptor(SignOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SignOp : public ::mlir::Op<SignOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsIdempotent, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SignOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Sign");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SignOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SinOp declarations
//===----------------------------------------------------------------------===//

class SinOpAdaptor {
public:
  SinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SinOpAdaptor(SinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SinOp : public ::mlir::Op<SinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Sin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SinhOp declarations
//===----------------------------------------------------------------------===//

class SinhOpAdaptor {
public:
  SinhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SinhOpAdaptor(SinhOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SinhOp : public ::mlir::Op<SinhOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SinhOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Sinh");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SinhOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SizeOp declarations
//===----------------------------------------------------------------------===//

class SizeOpAdaptor {
public:
  SizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SizeOpAdaptor(SizeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SizeOp : public ::mlir::Op<SizeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SizeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("out_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier out_typeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier out_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Size");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type out_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SizeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SliceOp declarations
//===----------------------------------------------------------------------===//

class SliceOpAdaptor {
public:
  SliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SliceOpAdaptor(SliceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value begin();
  ::mlir::Value size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SliceOp : public ::mlir::Op<SliceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SliceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Index"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier IndexAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier IndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Slice");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value begin();
  ::mlir::Value size();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange beginMutable();
  ::mlir::MutableOperandRange sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Index();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value size);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SliceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SnapshotOp declarations
//===----------------------------------------------------------------------===//

class SnapshotOpAdaptor {
public:
  SnapshotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SnapshotOpAdaptor(SnapshotOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SnapshotOp : public ::mlir::Op<SnapshotOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SnapshotOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Snapshot");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SnapshotOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftmaxCrossEntropyWithLogitsOp declarations
//===----------------------------------------------------------------------===//

class SoftmaxCrossEntropyWithLogitsOpAdaptor {
public:
  SoftmaxCrossEntropyWithLogitsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SoftmaxCrossEntropyWithLogitsOpAdaptor(SoftmaxCrossEntropyWithLogitsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::Value labels();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SoftmaxCrossEntropyWithLogitsOp : public ::mlir::Op<SoftmaxCrossEntropyWithLogitsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SoftmaxCrossEntropyWithLogitsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SoftmaxCrossEntropyWithLogits");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::Value labels();
  ::mlir::MutableOperandRange featuresMutable();
  ::mlir::MutableOperandRange labelsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value loss();
  ::mlir::Value backprop();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type loss, ::mlir::Type backprop, ::mlir::Value features, ::mlir::Value labels);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features, ::mlir::Value labels);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SoftmaxCrossEntropyWithLogitsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftmaxOp declarations
//===----------------------------------------------------------------------===//

class SoftmaxOpAdaptor {
public:
  SoftmaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SoftmaxOpAdaptor(SoftmaxOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value logits();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SoftmaxOp : public ::mlir::Op<SoftmaxOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SoftmaxOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Softmax");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value logits();
  ::mlir::MutableOperandRange logitsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value softmax();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type softmax, ::mlir::Value logits);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value logits);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value logits);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SoftmaxOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftplusGradOp declarations
//===----------------------------------------------------------------------===//

class SoftplusGradOpAdaptor {
public:
  SoftplusGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SoftplusGradOpAdaptor(SoftplusGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SoftplusGradOp : public ::mlir::Op<SoftplusGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SoftplusGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SoftplusGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::MutableOperandRange gradientsMutable();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value backprops();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SoftplusGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftplusOp declarations
//===----------------------------------------------------------------------===//

class SoftplusOpAdaptor {
public:
  SoftplusOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SoftplusOpAdaptor(SoftplusOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SoftplusOp : public ::mlir::Op<SoftplusOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SoftplusOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Softplus");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value activations();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SoftplusOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftsignGradOp declarations
//===----------------------------------------------------------------------===//

class SoftsignGradOpAdaptor {
public:
  SoftsignGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SoftsignGradOpAdaptor(SoftsignGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SoftsignGradOp : public ::mlir::Op<SoftsignGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SoftsignGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SoftsignGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value gradients();
  ::mlir::Value features();
  ::mlir::MutableOperandRange gradientsMutable();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value backprops();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SoftsignGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftsignOp declarations
//===----------------------------------------------------------------------===//

class SoftsignOpAdaptor {
public:
  SoftsignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SoftsignOpAdaptor(SoftsignOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SoftsignOp : public ::mlir::Op<SoftsignOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SoftsignOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Softsign");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::MutableOperandRange featuresMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value activations();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SoftsignOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SpaceToBatchNDOp declarations
//===----------------------------------------------------------------------===//

class SpaceToBatchNDOpAdaptor {
public:
  SpaceToBatchNDOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SpaceToBatchNDOpAdaptor(SpaceToBatchNDOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value block_shape();
  ::mlir::Value paddings();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SpaceToBatchNDOp : public ::mlir::Op<SpaceToBatchNDOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SpaceToBatchNDOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tblock_shape"), ::llvm::StringRef("Tpaddings")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier Tblock_shapeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier Tblock_shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TpaddingsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TpaddingsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SpaceToBatchND");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value block_shape();
  ::mlir::Value paddings();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange block_shapeMutable();
  ::mlir::MutableOperandRange paddingsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tblock_shape();
  ::mlir::Type Tpaddings();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value block_shape, ::mlir::Value paddings);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value block_shape, ::mlir::Value paddings);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    static bool isCompatibleReturnTypes(TypeRange l, TypeRange r) {
      return ArraysAreCastCompatible(l, r);
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SpaceToBatchNDOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SpaceToBatchOp declarations
//===----------------------------------------------------------------------===//

class SpaceToBatchOpAdaptor {
public:
  SpaceToBatchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SpaceToBatchOpAdaptor(SpaceToBatchOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value paddings();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr block_size();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SpaceToBatchOp : public ::mlir::Op<SpaceToBatchOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SpaceToBatchOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("block_size"), ::llvm::StringRef("T"), ::llvm::StringRef("Tpaddings")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier block_sizeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier block_sizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TpaddingsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TpaddingsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SpaceToBatch");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value paddings();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange paddingsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr block_sizeAttr();
  uint64_t block_size();
  ::mlir::Type T();
  ::mlir::Type Tpaddings();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void block_sizeAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, ::mlir::IntegerAttr block_size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, ::mlir::IntegerAttr block_size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, uint64_t block_size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, uint64_t block_size);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SpaceToBatchOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SpaceToDepthOp declarations
//===----------------------------------------------------------------------===//

class SpaceToDepthOpAdaptor {
public:
  SpaceToDepthOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SpaceToDepthOpAdaptor(SpaceToDepthOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr block_size();
  ::mlir::StringAttr data_format();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SpaceToDepthOp : public ::mlir::Op<SpaceToDepthOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SpaceToDepthOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("block_size"), ::llvm::StringRef("data_format"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier block_sizeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier block_sizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier data_formatAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier data_formatAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SpaceToDepth");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr block_sizeAttr();
  uint64_t block_size();
  ::mlir::StringAttr data_formatAttr();
  ::llvm::StringRef data_format();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void block_sizeAttr(::mlir::IntegerAttr attr);
  void data_formatAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr block_size, ::mlir::StringAttr data_format);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr block_size, ::mlir::StringAttr data_format);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t block_size, ::llvm::StringRef data_format = "NHWC");
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t block_size, ::llvm::StringRef data_format = "NHWC");
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SpaceToDepthOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseAddOp declarations
//===----------------------------------------------------------------------===//

class SparseAddOpAdaptor {
public:
  SparseAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseAddOpAdaptor(SparseAddOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value a_indices();
  ::mlir::Value a_values();
  ::mlir::Value a_shape();
  ::mlir::Value b_indices();
  ::mlir::Value b_values();
  ::mlir::Value b_shape();
  ::mlir::Value thresh();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseAddOp : public ::mlir::Op<SparseAddOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<7>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseAddOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Treal")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TrealAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TrealAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseAdd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value a_indices();
  ::mlir::Value a_values();
  ::mlir::Value a_shape();
  ::mlir::Value b_indices();
  ::mlir::Value b_values();
  ::mlir::Value b_shape();
  ::mlir::Value thresh();
  ::mlir::MutableOperandRange a_indicesMutable();
  ::mlir::MutableOperandRange a_valuesMutable();
  ::mlir::MutableOperandRange a_shapeMutable();
  ::mlir::MutableOperandRange b_indicesMutable();
  ::mlir::MutableOperandRange b_valuesMutable();
  ::mlir::MutableOperandRange b_shapeMutable();
  ::mlir::MutableOperandRange threshMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value sum_indices();
  ::mlir::Value sum_values();
  ::mlir::Value sum_shape();
  ::mlir::Type T();
  ::mlir::Type Treal();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type sum_indices, ::mlir::Type sum_values, ::mlir::Type sum_shape, ::mlir::Value a_indices, ::mlir::Value a_values, ::mlir::Value a_shape, ::mlir::Value b_indices, ::mlir::Value b_values, ::mlir::Value b_shape, ::mlir::Value thresh);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a_indices, ::mlir::Value a_values, ::mlir::Value a_shape, ::mlir::Value b_indices, ::mlir::Value b_values, ::mlir::Value b_shape, ::mlir::Value thresh);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseAddOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseFillEmptyRowsOp declarations
//===----------------------------------------------------------------------===//

class SparseFillEmptyRowsOpAdaptor {
public:
  SparseFillEmptyRowsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseFillEmptyRowsOpAdaptor(SparseFillEmptyRowsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value indices();
  ::mlir::Value values();
  ::mlir::Value dense_shape();
  ::mlir::Value default_value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseFillEmptyRowsOp : public ::mlir::Op<SparseFillEmptyRowsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<4>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseFillEmptyRowsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseFillEmptyRows");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value indices();
  ::mlir::Value values();
  ::mlir::Value dense_shape();
  ::mlir::Value default_value();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange valuesMutable();
  ::mlir::MutableOperandRange dense_shapeMutable();
  ::mlir::MutableOperandRange default_valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_indices();
  ::mlir::Value output_values();
  ::mlir::Value empty_row_indicator();
  ::mlir::Value reverse_index_map();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_indices, ::mlir::Type output_values, ::mlir::Type empty_row_indicator, ::mlir::Type reverse_index_map, ::mlir::Value indices, ::mlir::Value values, ::mlir::Value dense_shape, ::mlir::Value default_value);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value values, ::mlir::Value dense_shape, ::mlir::Value default_value);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseFillEmptyRowsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseMatMulOp declarations
//===----------------------------------------------------------------------===//

class SparseMatMulOpAdaptor {
public:
  SparseMatMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseMatMulOpAdaptor(SparseMatMulOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value b();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr transpose_a();
  ::mlir::BoolAttr transpose_b();
  ::mlir::BoolAttr a_is_sparse();
  ::mlir::BoolAttr b_is_sparse();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseMatMulOp : public ::mlir::Op<SparseMatMulOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseMatMulOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("transpose_a"), ::llvm::StringRef("transpose_b"), ::llvm::StringRef("a_is_sparse"), ::llvm::StringRef("b_is_sparse"), ::llvm::StringRef("Ta"), ::llvm::StringRef("Tb")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier transpose_aAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier transpose_aAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier transpose_bAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier transpose_bAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier a_is_sparseAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier a_is_sparseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier b_is_sparseAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier b_is_sparseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier TaAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier TaAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier TbAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier TbAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseMatMul");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value b();
  ::mlir::MutableOperandRange aMutable();
  ::mlir::MutableOperandRange bMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value product();
  ::mlir::BoolAttr transpose_aAttr();
  bool transpose_a();
  ::mlir::BoolAttr transpose_bAttr();
  bool transpose_b();
  ::mlir::BoolAttr a_is_sparseAttr();
  bool a_is_sparse();
  ::mlir::BoolAttr b_is_sparseAttr();
  bool b_is_sparse();
  ::mlir::Type Ta();
  ::mlir::Type Tb();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void transpose_aAttr(::mlir::BoolAttr attr);
  void transpose_bAttr(::mlir::BoolAttr attr);
  void a_is_sparseAttr(::mlir::BoolAttr attr);
  void b_is_sparseAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b, ::mlir::BoolAttr a_is_sparse, ::mlir::BoolAttr b_is_sparse);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b, ::mlir::BoolAttr a_is_sparse, ::mlir::BoolAttr b_is_sparse);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, bool transpose_a = false, bool transpose_b = false, bool a_is_sparse = false, bool b_is_sparse = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, bool transpose_a = false, bool transpose_b = false, bool a_is_sparse = false, bool b_is_sparse = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseMatMulOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseReduceSumOp declarations
//===----------------------------------------------------------------------===//

class SparseReduceSumOpAdaptor {
public:
  SparseReduceSumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseReduceSumOpAdaptor(SparseReduceSumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_indices();
  ::mlir::Value input_values();
  ::mlir::Value input_shape();
  ::mlir::Value reduction_axes();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr keep_dims();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseReduceSumOp : public ::mlir::Op<SparseReduceSumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseReduceSumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("keep_dims"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier keep_dimsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier keep_dimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseReduceSum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_indices();
  ::mlir::Value input_values();
  ::mlir::Value input_shape();
  ::mlir::Value reduction_axes();
  ::mlir::MutableOperandRange input_indicesMutable();
  ::mlir::MutableOperandRange input_valuesMutable();
  ::mlir::MutableOperandRange input_shapeMutable();
  ::mlir::MutableOperandRange reduction_axesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr keep_dimsAttr();
  bool keep_dims();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void keep_dimsAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_indices, ::mlir::Value input_values, ::mlir::Value input_shape, ::mlir::Value reduction_axes, ::mlir::BoolAttr keep_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_indices, ::mlir::Value input_values, ::mlir::Value input_shape, ::mlir::Value reduction_axes, ::mlir::BoolAttr keep_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_indices, ::mlir::Value input_values, ::mlir::Value input_shape, ::mlir::Value reduction_axes, bool keep_dims = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_indices, ::mlir::Value input_values, ::mlir::Value input_shape, ::mlir::Value reduction_axes, bool keep_dims = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseReduceSumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseReshapeOp declarations
//===----------------------------------------------------------------------===//

class SparseReshapeOpAdaptor {
public:
  SparseReshapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseReshapeOpAdaptor(SparseReshapeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_indices();
  ::mlir::Value input_shape();
  ::mlir::Value new_shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseReshapeOp : public ::mlir::Op<SparseReshapeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseReshapeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseReshape");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_indices();
  ::mlir::Value input_shape();
  ::mlir::Value new_shape();
  ::mlir::MutableOperandRange input_indicesMutable();
  ::mlir::MutableOperandRange input_shapeMutable();
  ::mlir::MutableOperandRange new_shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_indices();
  ::mlir::Value output_shape();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_indices, ::mlir::Type output_shape, ::mlir::Value input_indices, ::mlir::Value input_shape, ::mlir::Value new_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_indices, ::mlir::Value input_shape, ::mlir::Value new_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseReshapeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentMeanGradOp declarations
//===----------------------------------------------------------------------===//

class SparseSegmentMeanGradOpAdaptor {
public:
  SparseSegmentMeanGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSegmentMeanGradOpAdaptor(SparseSegmentMeanGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value grad();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value output_dim0();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSegmentMeanGradOp : public ::mlir::Op<SparseSegmentMeanGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSegmentMeanGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx"), ::llvm::StringRef("Tsegmentids")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TsegmentidsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TsegmentidsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSegmentMeanGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value grad();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value output_dim0();
  ::mlir::MutableOperandRange gradMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange output_dim0Mutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  ::mlir::Type Tsegmentids();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grad, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value output_dim0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grad, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value output_dim0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSegmentMeanGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentMeanOp declarations
//===----------------------------------------------------------------------===//

class SparseSegmentMeanOpAdaptor {
public:
  SparseSegmentMeanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSegmentMeanOpAdaptor(SparseSegmentMeanOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSegmentMeanOp : public ::mlir::Op<SparseSegmentMeanOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSegmentMeanOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx"), ::llvm::StringRef("Tsegmentids")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TsegmentidsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TsegmentidsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSegmentMean");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  ::mlir::Type Tsegmentids();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSegmentMeanOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentMeanWithNumSegmentsOp declarations
//===----------------------------------------------------------------------===//

class SparseSegmentMeanWithNumSegmentsOpAdaptor {
public:
  SparseSegmentMeanWithNumSegmentsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSegmentMeanWithNumSegmentsOpAdaptor(SparseSegmentMeanWithNumSegmentsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSegmentMeanWithNumSegmentsOp : public ::mlir::Op<SparseSegmentMeanWithNumSegmentsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSegmentMeanWithNumSegmentsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx"), ::llvm::StringRef("Tnumsegments"), ::llvm::StringRef("Tsegmentids")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TnumsegmentsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TnumsegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TsegmentidsAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TsegmentidsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSegmentMeanWithNumSegments");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange num_segmentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  ::mlir::Type Tnumsegments();
  ::mlir::Type Tsegmentids();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSegmentMeanWithNumSegmentsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentSqrtNGradOp declarations
//===----------------------------------------------------------------------===//

class SparseSegmentSqrtNGradOpAdaptor {
public:
  SparseSegmentSqrtNGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSegmentSqrtNGradOpAdaptor(SparseSegmentSqrtNGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value grad();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value output_dim0();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSegmentSqrtNGradOp : public ::mlir::Op<SparseSegmentSqrtNGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSegmentSqrtNGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx"), ::llvm::StringRef("Tsegmentids")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TsegmentidsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TsegmentidsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSegmentSqrtNGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value grad();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value output_dim0();
  ::mlir::MutableOperandRange gradMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange output_dim0Mutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  ::mlir::Type Tsegmentids();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grad, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value output_dim0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grad, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value output_dim0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSegmentSqrtNGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentSqrtNOp declarations
//===----------------------------------------------------------------------===//

class SparseSegmentSqrtNOpAdaptor {
public:
  SparseSegmentSqrtNOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSegmentSqrtNOpAdaptor(SparseSegmentSqrtNOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSegmentSqrtNOp : public ::mlir::Op<SparseSegmentSqrtNOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSegmentSqrtNOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx"), ::llvm::StringRef("Tsegmentids")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TsegmentidsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TsegmentidsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSegmentSqrtN");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  ::mlir::Type Tsegmentids();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSegmentSqrtNOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentSqrtNWithNumSegmentsOp declarations
//===----------------------------------------------------------------------===//

class SparseSegmentSqrtNWithNumSegmentsOpAdaptor {
public:
  SparseSegmentSqrtNWithNumSegmentsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSegmentSqrtNWithNumSegmentsOpAdaptor(SparseSegmentSqrtNWithNumSegmentsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSegmentSqrtNWithNumSegmentsOp : public ::mlir::Op<SparseSegmentSqrtNWithNumSegmentsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSegmentSqrtNWithNumSegmentsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx"), ::llvm::StringRef("Tnumsegments"), ::llvm::StringRef("Tsegmentids")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TnumsegmentsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TnumsegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TsegmentidsAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TsegmentidsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSegmentSqrtNWithNumSegments");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange num_segmentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  ::mlir::Type Tnumsegments();
  ::mlir::Type Tsegmentids();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSegmentSqrtNWithNumSegmentsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentSumOp declarations
//===----------------------------------------------------------------------===//

class SparseSegmentSumOpAdaptor {
public:
  SparseSegmentSumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSegmentSumOpAdaptor(SparseSegmentSumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSegmentSumOp : public ::mlir::Op<SparseSegmentSumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSegmentSumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tidx"), ::llvm::StringRef("Tsegmentids")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TsegmentidsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TsegmentidsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSegmentSum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value indices();
  ::mlir::Value segment_ids();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  ::mlir::Type Tsegmentids();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSegmentSumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSoftmaxCrossEntropyWithLogitsOp declarations
//===----------------------------------------------------------------------===//

class SparseSoftmaxCrossEntropyWithLogitsOpAdaptor {
public:
  SparseSoftmaxCrossEntropyWithLogitsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseSoftmaxCrossEntropyWithLogitsOpAdaptor(SparseSoftmaxCrossEntropyWithLogitsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::Value labels();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseSoftmaxCrossEntropyWithLogitsOp : public ::mlir::Op<SparseSoftmaxCrossEntropyWithLogitsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseSoftmaxCrossEntropyWithLogitsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tlabels")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TlabelsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TlabelsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseSoftmaxCrossEntropyWithLogits");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value features();
  ::mlir::Value labels();
  ::mlir::MutableOperandRange featuresMutable();
  ::mlir::MutableOperandRange labelsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value loss();
  ::mlir::Value backprop();
  ::mlir::Type T();
  ::mlir::Type Tlabels();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type loss, ::mlir::Type backprop, ::mlir::Value features, ::mlir::Value labels);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features, ::mlir::Value labels);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseSoftmaxCrossEntropyWithLogitsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseToDenseOp declarations
//===----------------------------------------------------------------------===//

class SparseToDenseOpAdaptor {
public:
  SparseToDenseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SparseToDenseOpAdaptor(SparseToDenseOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value sparse_indices();
  ::mlir::Value output_shape();
  ::mlir::Value sparse_values();
  ::mlir::Value default_value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr validate_indices();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SparseToDenseOp : public ::mlir::Op<SparseToDenseOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SparseToDenseOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("validate_indices"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier validate_indicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier validate_indicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SparseToDense");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value sparse_indices();
  ::mlir::Value output_shape();
  ::mlir::Value sparse_values();
  ::mlir::Value default_value();
  ::mlir::MutableOperandRange sparse_indicesMutable();
  ::mlir::MutableOperandRange output_shapeMutable();
  ::mlir::MutableOperandRange sparse_valuesMutable();
  ::mlir::MutableOperandRange default_valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value dense();
  ::mlir::BoolAttr validate_indicesAttr();
  bool validate_indices();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void validate_indicesAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type dense, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, ::mlir::BoolAttr validate_indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, ::mlir::BoolAttr validate_indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type dense, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, bool validate_indices = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, bool validate_indices = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SparseToDenseOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SplitOp declarations
//===----------------------------------------------------------------------===//

class SplitOpAdaptor {
public:
  SplitOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SplitOpAdaptor(SplitOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value split_dim();
  ::mlir::Value value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SplitOp : public ::mlir::Op<SplitOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SplitOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("num_split")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier num_splitAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier num_splitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Split");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value split_dim();
  ::mlir::Value value();
  ::mlir::MutableOperandRange split_dimMutable();
  ::mlir::MutableOperandRange valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::Type T();
  size_t num_split();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value split_dim, ::mlir::Value value);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SplitOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SplitVOp declarations
//===----------------------------------------------------------------------===//

class SplitVOpAdaptor {
public:
  SplitVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SplitVOpAdaptor(SplitVOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value value();
  ::mlir::Value size_splits();
  ::mlir::Value split_dim();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SplitVOp : public ::mlir::Op<SplitVOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SplitVOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tlen"), ::llvm::StringRef("num_split")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TlenAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TlenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier num_splitAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier num_splitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SplitV");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value value();
  ::mlir::Value size_splits();
  ::mlir::Value split_dim();
  ::mlir::MutableOperandRange valueMutable();
  ::mlir::MutableOperandRange size_splitsMutable();
  ::mlir::MutableOperandRange split_dimMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::Type T();
  ::mlir::Type Tlen();
  size_t num_split();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value value, ::mlir::Value size_splits, ::mlir::Value split_dim);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SplitVOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SqrtGradOp declarations
//===----------------------------------------------------------------------===//

class SqrtGradOpAdaptor {
public:
  SqrtGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SqrtGradOpAdaptor(SqrtGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SqrtGradOp : public ::mlir::Op<SqrtGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SqrtGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SqrtGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::MutableOperandRange yMutable();
  ::mlir::MutableOperandRange dyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SqrtGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SqrtOp declarations
//===----------------------------------------------------------------------===//

class SqrtOpAdaptor {
public:
  SqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SqrtOpAdaptor(SqrtOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SqrtOp : public ::mlir::Op<SqrtOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SqrtOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Sqrt");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SqrtOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SquareOp declarations
//===----------------------------------------------------------------------===//

class SquareOpAdaptor {
public:
  SquareOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SquareOpAdaptor(SquareOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SquareOp : public ::mlir::Op<SquareOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SquareOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Square");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SquareOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SquaredDifferenceOp declarations
//===----------------------------------------------------------------------===//

class SquaredDifferenceOpAdaptor {
public:
  SquaredDifferenceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SquaredDifferenceOpAdaptor(SquaredDifferenceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SquaredDifferenceOp : public ::mlir::Op<SquaredDifferenceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::IsCommutative, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SquaredDifferenceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SquaredDifference");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SquaredDifferenceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SqueezeOp declarations
//===----------------------------------------------------------------------===//

class SqueezeOpAdaptor {
public:
  SqueezeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SqueezeOpAdaptor(SqueezeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr squeeze_dims();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SqueezeOp : public ::mlir::Op<SqueezeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SqueezeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("squeeze_dims"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier squeeze_dimsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier squeeze_dimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Squeeze");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::ArrayAttr squeeze_dimsAttr();
  ::mlir::ArrayAttr squeeze_dims();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void squeeze_dimsAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr squeeze_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr squeeze_dims);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SqueezeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackCloseV2Op declarations
//===----------------------------------------------------------------------===//

class StackCloseV2OpAdaptor {
public:
  StackCloseV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StackCloseV2OpAdaptor(StackCloseV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StackCloseV2Op : public ::mlir::Op<StackCloseV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StackCloseV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StackCloseV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::MutableOperandRange handleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StackCloseV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackPopV2Op declarations
//===----------------------------------------------------------------------===//

class StackPopV2OpAdaptor {
public:
  StackPopV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StackPopV2OpAdaptor(StackPopV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StackPopV2Op : public ::mlir::Op<StackPopV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StackPopV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("elem_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier elem_typeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier elem_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StackPopV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::MutableOperandRange handleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value elem();
  ::mlir::Type elem_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type elem, ::mlir::Value handle);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StackPopV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackPushV2Op declarations
//===----------------------------------------------------------------------===//

class StackPushV2OpAdaptor {
public:
  StackPushV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StackPushV2OpAdaptor(StackPushV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value elem();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr swap_memory();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StackPushV2Op : public ::mlir::Op<StackPushV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StackPushV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("swap_memory"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier swap_memoryAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier swap_memoryAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StackPushV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value elem();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange elemMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr swap_memoryAttr();
  bool swap_memory();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void swap_memoryAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value handle, ::mlir::Value elem, ::mlir::BoolAttr swap_memory);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value elem, ::mlir::BoolAttr swap_memory);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value handle, ::mlir::Value elem, bool swap_memory = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value elem, bool swap_memory = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StackPushV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackV2Op declarations
//===----------------------------------------------------------------------===//

class StackV2OpAdaptor {
public:
  StackV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StackV2OpAdaptor(StackV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value max_size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::TypeAttr elem_type();
  ::mlir::StringAttr stack_name();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StackV2Op : public ::mlir::Op<StackV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ResourceHandleAllocatorInterface::Trait, ::mlir::OpTrait::TF::UniqueResourceAllocation, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StackV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("elem_type"), ::llvm::StringRef("stack_name")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier elem_typeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier elem_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier stack_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier stack_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StackV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value max_size();
  ::mlir::MutableOperandRange max_sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::TypeAttr elem_typeAttr();
  ::mlir::Type elem_type();
  ::mlir::StringAttr stack_nameAttr();
  ::llvm::StringRef stack_name();
  void elem_typeAttr(::mlir::TypeAttr attr);
  void stack_nameAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value max_size, ::mlir::TypeAttr elem_type, ::mlir::StringAttr stack_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value max_size, ::mlir::TypeAttr elem_type, ::mlir::StringAttr stack_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value max_size, ::mlir::Type elem_type, ::llvm::StringRef stack_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value max_size, ::mlir::Type elem_type, ::llvm::StringRef stack_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StackV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulPartitionedCallOp declarations
//===----------------------------------------------------------------------===//

class StatefulPartitionedCallOpAdaptor {
public:
  StatefulPartitionedCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatefulPartitionedCallOpAdaptor(StatefulPartitionedCallOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange args();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::FlatSymbolRefAttr f();
  ::mlir::StringAttr config();
  ::mlir::StringAttr config_proto();
  ::mlir::StringAttr executor_type();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatefulPartitionedCallOp : public ::mlir::Op<StatefulPartitionedCallOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::CallOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatefulPartitionedCallOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("config"), ::llvm::StringRef("config_proto"), ::llvm::StringRef("executor_type"), ::llvm::StringRef("Tin"), ::llvm::StringRef("Tout")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier configAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier config_protoAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier config_protoAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier executor_typeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier executor_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier TinAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier TinAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier ToutAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier ToutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatefulPartitionedCall");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range args();
  ::mlir::MutableOperandRange argsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::FlatSymbolRefAttr fAttr();
  ::llvm::StringRef f();
  ::mlir::StringAttr configAttr();
  ::llvm::StringRef config();
  ::mlir::StringAttr config_protoAttr();
  ::llvm::StringRef config_proto();
  ::mlir::StringAttr executor_typeAttr();
  ::llvm::StringRef executor_type();
  mlir::OperandElementTypeRange Tin();
  mlir::ResultElementTypeRange Tout();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void fAttr(::mlir::FlatSymbolRefAttr attr);
  void configAttr(::mlir::StringAttr attr);
  void config_protoAttr(::mlir::StringAttr attr);
  void executor_typeAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::FlatSymbolRefAttr f, ::mlir::StringAttr config, ::mlir::StringAttr config_proto, ::mlir::StringAttr executor_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::llvm::StringRef f, ::llvm::StringRef config, ::llvm::StringRef config_proto, ::llvm::StringRef executor_type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

    // Gets the argument operands to the called function.
    operand_range getArgOperands() { return args(); }

    // Returns the callee of this operation.
    CallInterfaceCallable getCallableForCallee() { return fAttr(); }

    // returns the callee of this operation.
    FuncOp func() {
      return SymbolTable::lookupNearestSymbolFrom<FuncOp>(*this, fAttr());
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatefulPartitionedCallOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulStandardNormalV2Op declarations
//===----------------------------------------------------------------------===//

class StatefulStandardNormalV2OpAdaptor {
public:
  StatefulStandardNormalV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatefulStandardNormalV2OpAdaptor(StatefulStandardNormalV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatefulStandardNormalV2Op : public ::mlir::Op<StatefulStandardNormalV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatefulStandardNormalV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_dtype"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatefulStandardNormalV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange algorithmMutable();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type shape_dtype();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatefulStandardNormalV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulTruncatedNormalOp declarations
//===----------------------------------------------------------------------===//

class StatefulTruncatedNormalOpAdaptor {
public:
  StatefulTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatefulTruncatedNormalOpAdaptor(StatefulTruncatedNormalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatefulTruncatedNormalOp : public ::mlir::Op<StatefulTruncatedNormalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatefulTruncatedNormalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_dtype"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatefulTruncatedNormal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange algorithmMutable();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type shape_dtype();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatefulTruncatedNormalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulUniformFullIntOp declarations
//===----------------------------------------------------------------------===//

class StatefulUniformFullIntOpAdaptor {
public:
  StatefulUniformFullIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatefulUniformFullIntOpAdaptor(StatefulUniformFullIntOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatefulUniformFullIntOp : public ::mlir::Op<StatefulUniformFullIntOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatefulUniformFullIntOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_dtype"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatefulUniformFullInt");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange algorithmMutable();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type shape_dtype();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatefulUniformFullIntOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulUniformIntOp declarations
//===----------------------------------------------------------------------===//

class StatefulUniformIntOpAdaptor {
public:
  StatefulUniformIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatefulUniformIntOpAdaptor(StatefulUniformIntOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatefulUniformIntOp : public ::mlir::Op<StatefulUniformIntOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatefulUniformIntOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_dtype"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatefulUniformInt");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange algorithmMutable();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange minvalMutable();
  ::mlir::MutableOperandRange maxvalMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type shape_dtype();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatefulUniformIntOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulUniformOp declarations
//===----------------------------------------------------------------------===//

class StatefulUniformOpAdaptor {
public:
  StatefulUniformOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatefulUniformOpAdaptor(StatefulUniformOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatefulUniformOp : public ::mlir::Op<StatefulUniformOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatefulUniformOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_dtype"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatefulUniform");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::Value algorithm();
  ::mlir::Value shape();
  ::mlir::MutableOperandRange resourceMutable();
  ::mlir::MutableOperandRange algorithmMutable();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type shape_dtype();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatefulUniformOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessMultinomialOp declarations
//===----------------------------------------------------------------------===//

class StatelessMultinomialOpAdaptor {
public:
  StatelessMultinomialOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessMultinomialOpAdaptor(StatelessMultinomialOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value logits();
  ::mlir::Value num_samples();
  ::mlir::Value seed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessMultinomialOp : public ::mlir::Op<StatelessMultinomialOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessMultinomialOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("output_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier output_dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier output_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessMultinomial");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value logits();
  ::mlir::Value num_samples();
  ::mlir::Value seed();
  ::mlir::MutableOperandRange logitsMutable();
  ::mlir::MutableOperandRange num_samplesMutable();
  ::mlir::MutableOperandRange seedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type output_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value logits, ::mlir::Value num_samples, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value logits, ::mlir::Value num_samples, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessMultinomialOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessParameterizedTruncatedNormalOp declarations
//===----------------------------------------------------------------------===//

class StatelessParameterizedTruncatedNormalOpAdaptor {
public:
  StatelessParameterizedTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessParameterizedTruncatedNormalOpAdaptor(StatelessParameterizedTruncatedNormalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value means();
  ::mlir::Value stddevs();
  ::mlir::Value minvals();
  ::mlir::Value maxvals();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessParameterizedTruncatedNormalOp : public ::mlir::Op<StatelessParameterizedTruncatedNormalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<6>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessParameterizedTruncatedNormalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("S"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier SAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier SAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessParameterizedTruncatedNormal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value means();
  ::mlir::Value stddevs();
  ::mlir::Value minvals();
  ::mlir::Value maxvals();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  ::mlir::MutableOperandRange meansMutable();
  ::mlir::MutableOperandRange stddevsMutable();
  ::mlir::MutableOperandRange minvalsMutable();
  ::mlir::MutableOperandRange maxvalsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type S();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value means, ::mlir::Value stddevs, ::mlir::Value minvals, ::mlir::Value maxvals);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value means, ::mlir::Value stddevs, ::mlir::Value minvals, ::mlir::Value maxvals);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessParameterizedTruncatedNormalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomBinomialOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomBinomialOpAdaptor {
public:
  StatelessRandomBinomialOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomBinomialOpAdaptor(StatelessRandomBinomialOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value counts();
  ::mlir::Value probs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomBinomialOp : public ::mlir::Op<StatelessRandomBinomialOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomBinomialOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("S"), ::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier SAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier SAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomBinomial");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value counts();
  ::mlir::Value probs();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  ::mlir::MutableOperandRange countsMutable();
  ::mlir::MutableOperandRange probsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type S();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value counts, ::mlir::Value probs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value counts, ::mlir::Value probs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomBinomialOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomGammaV2Op declarations
//===----------------------------------------------------------------------===//

class StatelessRandomGammaV2OpAdaptor {
public:
  StatelessRandomGammaV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomGammaV2OpAdaptor(StatelessRandomGammaV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value alpha();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomGammaV2Op : public ::mlir::Op<StatelessRandomGammaV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomGammaV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomGammaV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value alpha();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  ::mlir::MutableOperandRange alphaMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value alpha);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value alpha);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomGammaV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomGetAlgOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomGetAlgOpAdaptor {
public:
  StatelessRandomGetAlgOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomGetAlgOpAdaptor(StatelessRandomGetAlgOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomGetAlgOp : public ::mlir::Op<StatelessRandomGetAlgOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomGetAlgOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomGetAlg");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value alg();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type alg);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomGetAlgOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomGetKeyCounterAlgOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomGetKeyCounterAlgOpAdaptor {
public:
  StatelessRandomGetKeyCounterAlgOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomGetKeyCounterAlgOpAdaptor(StatelessRandomGetKeyCounterAlgOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value seed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomGetKeyCounterAlgOp : public ::mlir::Op<StatelessRandomGetKeyCounterAlgOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomGetKeyCounterAlgOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tseed")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomGetKeyCounterAlg");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value seed();
  ::mlir::MutableOperandRange seedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::Type Tseed();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type key, ::mlir::Type counter, ::mlir::Type alg, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomGetKeyCounterAlgOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomGetKeyCounterOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomGetKeyCounterOpAdaptor {
public:
  StatelessRandomGetKeyCounterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomGetKeyCounterOpAdaptor(StatelessRandomGetKeyCounterOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value seed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomGetKeyCounterOp : public ::mlir::Op<StatelessRandomGetKeyCounterOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomGetKeyCounterOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tseed")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomGetKeyCounter");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value seed();
  ::mlir::MutableOperandRange seedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Type Tseed();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type key, ::mlir::Type counter, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomGetKeyCounterOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomNormalOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomNormalOpAdaptor {
public:
  StatelessRandomNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomNormalOpAdaptor(StatelessRandomNormalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomNormalOp : public ::mlir::Op<StatelessRandomNormalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomNormalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomNormal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomNormalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomNormalV2Op declarations
//===----------------------------------------------------------------------===//

class StatelessRandomNormalV2OpAdaptor {
public:
  StatelessRandomNormalV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomNormalV2OpAdaptor(StatelessRandomNormalV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomNormalV2Op : public ::mlir::Op<StatelessRandomNormalV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomNormalV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tshape"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TshapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TshapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomNormalV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange keyMutable();
  ::mlir::MutableOperandRange counterMutable();
  ::mlir::MutableOperandRange algMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Tshape();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomNormalV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomPoissonOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomPoissonOpAdaptor {
public:
  StatelessRandomPoissonOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomPoissonOpAdaptor(StatelessRandomPoissonOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value lam();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomPoissonOp : public ::mlir::Op<StatelessRandomPoissonOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomPoissonOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Rtype"), ::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier RtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier RtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomPoisson");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value lam();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  ::mlir::MutableOperandRange lamMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Rtype();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value lam);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value lam);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomPoissonOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformFullIntOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomUniformFullIntOpAdaptor {
public:
  StatelessRandomUniformFullIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomUniformFullIntOpAdaptor(StatelessRandomUniformFullIntOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomUniformFullIntOp : public ::mlir::Op<StatelessRandomUniformFullIntOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomUniformFullIntOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomUniformFullInt");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomUniformFullIntOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformFullIntV2Op declarations
//===----------------------------------------------------------------------===//

class StatelessRandomUniformFullIntV2OpAdaptor {
public:
  StatelessRandomUniformFullIntV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomUniformFullIntV2OpAdaptor(StatelessRandomUniformFullIntV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomUniformFullIntV2Op : public ::mlir::Op<StatelessRandomUniformFullIntV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomUniformFullIntV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tshape"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TshapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TshapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomUniformFullIntV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange keyMutable();
  ::mlir::MutableOperandRange counterMutable();
  ::mlir::MutableOperandRange algMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Tshape();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomUniformFullIntV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformIntOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomUniformIntOpAdaptor {
public:
  StatelessRandomUniformIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomUniformIntOpAdaptor(StatelessRandomUniformIntOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomUniformIntOp : public ::mlir::Op<StatelessRandomUniformIntOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomUniformIntOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomUniformInt");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  ::mlir::MutableOperandRange minvalMutable();
  ::mlir::MutableOperandRange maxvalMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value minval, ::mlir::Value maxval);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value minval, ::mlir::Value maxval);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomUniformIntOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformIntV2Op declarations
//===----------------------------------------------------------------------===//

class StatelessRandomUniformIntV2OpAdaptor {
public:
  StatelessRandomUniformIntV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomUniformIntV2OpAdaptor(StatelessRandomUniformIntV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomUniformIntV2Op : public ::mlir::Op<StatelessRandomUniformIntV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<6>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomUniformIntV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tshape"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TshapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TshapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomUniformIntV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::Value minval();
  ::mlir::Value maxval();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange keyMutable();
  ::mlir::MutableOperandRange counterMutable();
  ::mlir::MutableOperandRange algMutable();
  ::mlir::MutableOperandRange minvalMutable();
  ::mlir::MutableOperandRange maxvalMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Tshape();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg, ::mlir::Value minval, ::mlir::Value maxval);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg, ::mlir::Value minval, ::mlir::Value maxval);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomUniformIntV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformOp declarations
//===----------------------------------------------------------------------===//

class StatelessRandomUniformOpAdaptor {
public:
  StatelessRandomUniformOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomUniformOpAdaptor(StatelessRandomUniformOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomUniformOp : public ::mlir::Op<StatelessRandomUniformOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomUniformOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomUniform");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomUniformOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformV2Op declarations
//===----------------------------------------------------------------------===//

class StatelessRandomUniformV2OpAdaptor {
public:
  StatelessRandomUniformV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessRandomUniformV2OpAdaptor(StatelessRandomUniformV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessRandomUniformV2Op : public ::mlir::Op<StatelessRandomUniformV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessRandomUniformV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tshape"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TshapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TshapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessRandomUniformV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange keyMutable();
  ::mlir::MutableOperandRange counterMutable();
  ::mlir::MutableOperandRange algMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Tshape();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessRandomUniformV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessTruncatedNormalOp declarations
//===----------------------------------------------------------------------===//

class StatelessTruncatedNormalOpAdaptor {
public:
  StatelessTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessTruncatedNormalOpAdaptor(StatelessTruncatedNormalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessTruncatedNormalOp : public ::mlir::Op<StatelessTruncatedNormalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessTruncatedNormalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tseed"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TseedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TseedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessTruncatedNormal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value seed();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange seedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tseed();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessTruncatedNormalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessTruncatedNormalV2Op declarations
//===----------------------------------------------------------------------===//

class StatelessTruncatedNormalV2OpAdaptor {
public:
  StatelessTruncatedNormalV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StatelessTruncatedNormalV2OpAdaptor(StatelessTruncatedNormalV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StatelessTruncatedNormalV2Op : public ::mlir::Op<StatelessTruncatedNormalV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StatelessTruncatedNormalV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tshape"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TshapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TshapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StatelessTruncatedNormalV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value key();
  ::mlir::Value counter();
  ::mlir::Value alg();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange keyMutable();
  ::mlir::MutableOperandRange counterMutable();
  ::mlir::MutableOperandRange algMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type Tshape();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value key, ::mlir::Value counter, ::mlir::Value alg);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StatelessTruncatedNormalV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StaticRegexFullMatchOp declarations
//===----------------------------------------------------------------------===//

class StaticRegexFullMatchOpAdaptor {
public:
  StaticRegexFullMatchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StaticRegexFullMatchOpAdaptor(StaticRegexFullMatchOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr pattern();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StaticRegexFullMatchOp : public ::mlir::Op<StaticRegexFullMatchOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultShape> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StaticRegexFullMatchOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("pattern")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier patternAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier patternAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StaticRegexFullMatch");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr patternAttr();
  ::llvm::StringRef pattern();
  void patternAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::StringAttr pattern);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr pattern);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::llvm::StringRef pattern);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef pattern);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StaticRegexFullMatchOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StopGradientOp declarations
//===----------------------------------------------------------------------===//

class StopGradientOpAdaptor {
public:
  StopGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StopGradientOpAdaptor(StopGradientOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StopGradientOp : public ::mlir::Op<StopGradientOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StopGradientOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StopGradient");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StopGradientOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StridedSliceGradOp declarations
//===----------------------------------------------------------------------===//

class StridedSliceGradOpAdaptor {
public:
  StridedSliceGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StridedSliceGradOpAdaptor(StridedSliceGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::Value dy();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr begin_mask();
  ::mlir::IntegerAttr end_mask();
  ::mlir::IntegerAttr ellipsis_mask();
  ::mlir::IntegerAttr new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_mask();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StridedSliceGradOp : public ::mlir::Op<StridedSliceGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StridedSliceGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("begin_mask"), ::llvm::StringRef("end_mask"), ::llvm::StringRef("ellipsis_mask"), ::llvm::StringRef("new_axis_mask"), ::llvm::StringRef("shrink_axis_mask"), ::llvm::StringRef("Index"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier begin_maskAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier begin_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier end_maskAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier end_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier ellipsis_maskAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier ellipsis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier new_axis_maskAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier new_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier shrink_axis_maskAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier shrink_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier IndexAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier IndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StridedSliceGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::Value dy();
  ::mlir::MutableOperandRange shapeMutable();
  ::mlir::MutableOperandRange beginMutable();
  ::mlir::MutableOperandRange endMutable();
  ::mlir::MutableOperandRange stridesMutable();
  ::mlir::MutableOperandRange dyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr begin_maskAttr();
  uint64_t begin_mask();
  ::mlir::IntegerAttr end_maskAttr();
  uint64_t end_mask();
  ::mlir::IntegerAttr ellipsis_maskAttr();
  uint64_t ellipsis_mask();
  ::mlir::IntegerAttr new_axis_maskAttr();
  uint64_t new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_maskAttr();
  uint64_t shrink_axis_mask();
  ::mlir::Type Index();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void begin_maskAttr(::mlir::IntegerAttr attr);
  void end_maskAttr(::mlir::IntegerAttr attr);
  void ellipsis_maskAttr(::mlir::IntegerAttr attr);
  void new_axis_maskAttr(::mlir::IntegerAttr attr);
  void shrink_axis_maskAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // If sliced shape is able to be deduced, returns true, updates `shape`
    // with the final shape after performing StridedSlice, and updates
    // `begin_indices`, `end_indices`, and `strides` with their canonical
    // values, respectively.
    bool GetSlicedShapeAndBoundRanges(
      ::llvm::SmallVectorImpl<int64_t> *input_shape,
      ::llvm::SmallVectorImpl<int64_t> *slice_begin,
      ::llvm::SmallVectorImpl<int64_t> *slice_end,
      ::llvm::SmallVectorImpl<int64_t> *slice_stride);
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StridedSliceGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StridedSliceOp declarations
//===----------------------------------------------------------------------===//

class StridedSliceOpAdaptor {
public:
  StridedSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StridedSliceOpAdaptor(StridedSliceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr begin_mask();
  ::mlir::IntegerAttr end_mask();
  ::mlir::IntegerAttr ellipsis_mask();
  ::mlir::IntegerAttr new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_mask();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StridedSliceOp : public ::mlir::Op<StridedSliceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StridedSliceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("begin_mask"), ::llvm::StringRef("end_mask"), ::llvm::StringRef("ellipsis_mask"), ::llvm::StringRef("new_axis_mask"), ::llvm::StringRef("shrink_axis_mask"), ::llvm::StringRef("Index"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier begin_maskAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier begin_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier end_maskAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier end_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier ellipsis_maskAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier ellipsis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier new_axis_maskAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier new_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier shrink_axis_maskAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier shrink_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier IndexAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier IndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StridedSlice");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange beginMutable();
  ::mlir::MutableOperandRange endMutable();
  ::mlir::MutableOperandRange stridesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr begin_maskAttr();
  uint64_t begin_mask();
  ::mlir::IntegerAttr end_maskAttr();
  uint64_t end_mask();
  ::mlir::IntegerAttr ellipsis_maskAttr();
  uint64_t ellipsis_mask();
  ::mlir::IntegerAttr new_axis_maskAttr();
  uint64_t new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_maskAttr();
  uint64_t shrink_axis_mask();
  ::mlir::Type Index();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void begin_maskAttr(::mlir::IntegerAttr attr);
  void end_maskAttr(::mlir::IntegerAttr attr);
  void ellipsis_maskAttr(::mlir::IntegerAttr attr);
  void new_axis_maskAttr(::mlir::IntegerAttr attr);
  void shrink_axis_maskAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // If sliced shape is able to be deduced, returns true, updates
    // `begin_indices`, `end_indices`, and `strides` with their canonical
    // values, respectively.
    bool GetSlicedBoundRanges(
      ::llvm::SmallVectorImpl<int64_t> *slice_begin,
      ::llvm::SmallVectorImpl<int64_t> *slice_end,
      ::llvm::SmallVectorImpl<int64_t> *slice_stride);
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StridedSliceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StringFormatOp declarations
//===----------------------------------------------------------------------===//

class StringFormatOpAdaptor {
public:
  StringFormatOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StringFormatOpAdaptor(StringFormatOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr strtemplate();
  ::mlir::StringAttr placeholder();
  ::mlir::IntegerAttr summarize();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StringFormatOp : public ::mlir::Op<StringFormatOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StringFormatOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("strtemplate"), ::llvm::StringRef("placeholder"), ::llvm::StringRef("summarize"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier strtemplateAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier strtemplateAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier placeholderAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier placeholderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier summarizeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier summarizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StringFormat");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::MutableOperandRange inputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr strtemplateAttr();
  ::llvm::StringRef strtemplate();
  ::mlir::StringAttr placeholderAttr();
  ::llvm::StringRef placeholder();
  ::mlir::IntegerAttr summarizeAttr();
  uint64_t summarize();
  mlir::OperandElementTypeRange T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void strtemplateAttr(::mlir::StringAttr attr);
  void placeholderAttr(::mlir::StringAttr attr);
  void summarizeAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::StringAttr strtemplate, ::mlir::StringAttr placeholder, ::mlir::IntegerAttr summarize);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::StringAttr strtemplate, ::mlir::StringAttr placeholder, ::mlir::IntegerAttr summarize);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::llvm::StringRef strtemplate = "%s", ::llvm::StringRef placeholder = "%s", uint64_t summarize = 3);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::llvm::StringRef strtemplate = "%s", ::llvm::StringRef placeholder = "%s", uint64_t summarize = 3);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StringFormatOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StringJoinOp declarations
//===----------------------------------------------------------------------===//

class StringJoinOpAdaptor {
public:
  StringJoinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StringJoinOpAdaptor(StringJoinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr separator();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StringJoinOp : public ::mlir::Op<StringJoinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StringJoinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("separator"), ::llvm::StringRef("N")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier separatorAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier separatorAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StringJoin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::MutableOperandRange inputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr separatorAttr();
  ::llvm::StringRef separator();
  size_t N();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void separatorAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::StringAttr separator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::StringAttr separator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::llvm::StringRef separator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::llvm::StringRef separator);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StringJoinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StringStripOp declarations
//===----------------------------------------------------------------------===//

class StringStripOpAdaptor {
public:
  StringStripOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StringStripOpAdaptor(StringStripOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StringStripOp : public ::mlir::Op<StringStripOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StringStripOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StringStrip");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StringStripOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StringToHashBucketFastOp declarations
//===----------------------------------------------------------------------===//

class StringToHashBucketFastOpAdaptor {
public:
  StringToHashBucketFastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  StringToHashBucketFastOpAdaptor(StringToHashBucketFastOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr num_buckets();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class StringToHashBucketFastOp : public ::mlir::Op<StringToHashBucketFastOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = StringToHashBucketFastOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("num_buckets")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier num_bucketsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier num_bucketsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.StringToHashBucketFast");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr num_bucketsAttr();
  uint64_t num_buckets();
  void num_bucketsAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr num_buckets);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr num_buckets);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t num_buckets);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t num_buckets);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::StringToHashBucketFastOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SubOp declarations
//===----------------------------------------------------------------------===//

class SubOpAdaptor {
public:
  SubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SubOpAdaptor(SubOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SubOp : public ::mlir::Op<SubOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::OpTrait::TF::CwiseBinary, ::mlir::OpTrait::TF::SameOperandsAndResultElementTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SubOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Sub");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SubOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SumOp declarations
//===----------------------------------------------------------------------===//

class SumOpAdaptor {
public:
  SumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SumOpAdaptor(SumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value reduction_indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr keep_dims();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SumOp : public ::mlir::Op<SumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("keep_dims"), ::llvm::StringRef("T"), ::llvm::StringRef("Tidx")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier keep_dimsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier keep_dimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TidxAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TidxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Sum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value reduction_indices();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange reduction_indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr keep_dimsAttr();
  bool keep_dims();
  ::mlir::Type T();
  ::mlir::Type Tidx();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void keep_dimsAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value input, Value reduction_indices, BoolAttr keep_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SummaryWriterOp declarations
//===----------------------------------------------------------------------===//

class SummaryWriterOpAdaptor {
public:
  SummaryWriterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SummaryWriterOpAdaptor(SummaryWriterOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr shared_name();
  ::mlir::StringAttr container();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SummaryWriterOp : public ::mlir::Op<SummaryWriterOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ResourceHandleAllocatorInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SummaryWriterOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shared_name"), ::llvm::StringRef("container")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shared_nameAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shared_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier containerAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier containerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SummaryWriter");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value writer();
  ::mlir::StringAttr shared_nameAttr();
  ::llvm::StringRef shared_name();
  ::mlir::StringAttr containerAttr();
  ::llvm::StringRef container();
  void shared_nameAttr(::mlir::StringAttr attr);
  void containerAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type writer, ::mlir::StringAttr shared_name, ::mlir::StringAttr container);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr shared_name, ::mlir::StringAttr container);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type writer, ::llvm::StringRef shared_name, ::llvm::StringRef container);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef shared_name, ::llvm::StringRef container);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  llvm::SmallVector<ResourceHandleValueAndId, 4> GetResourceHandleValueAndIdList(llvm::SmallDenseMap<ResourceHandle, int64_t>&resource_handle_id_map, int64_t&next_id);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SummaryWriterOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SvdOp declarations
//===----------------------------------------------------------------------===//

class SvdOpAdaptor {
public:
  SvdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SvdOpAdaptor(SvdOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr compute_uv();
  ::mlir::BoolAttr full_matrices();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SvdOp : public ::mlir::Op<SvdOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SvdOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("compute_uv"), ::llvm::StringRef("full_matrices"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier compute_uvAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier compute_uvAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier full_matricesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier full_matricesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Svd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value s();
  ::mlir::Value u();
  ::mlir::Value v();
  ::mlir::BoolAttr compute_uvAttr();
  bool compute_uv();
  ::mlir::BoolAttr full_matricesAttr();
  bool full_matrices();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void compute_uvAttr(::mlir::BoolAttr attr);
  void full_matricesAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type s, ::mlir::Type u, ::mlir::Type v, ::mlir::Value input, ::mlir::BoolAttr compute_uv, ::mlir::BoolAttr full_matrices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr compute_uv, ::mlir::BoolAttr full_matrices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type s, ::mlir::Type u, ::mlir::Type v, ::mlir::Value input, bool compute_uv = true, bool full_matrices = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool compute_uv = true, bool full_matrices = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SvdOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SymbolicGradientOp declarations
//===----------------------------------------------------------------------===//

class SymbolicGradientOpAdaptor {
public:
  SymbolicGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  SymbolicGradientOpAdaptor(SymbolicGradientOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr f();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class SymbolicGradientOp : public ::mlir::Op<SymbolicGradientOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SymbolicGradientOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("Tin"), ::llvm::StringRef("Tout")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TinAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TinAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier ToutAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier ToutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.SymbolicGradient");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::SymbolRefAttr fAttr();
  ::mlir::SymbolRefAttr f();
  mlir::OperandElementTypeRange Tin();
  mlir::ResultElementTypeRange Tout();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void fAttr(::mlir::SymbolRefAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::mlir::SymbolRefAttr f);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::SymbolicGradientOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUCompilationResultOp declarations
//===----------------------------------------------------------------------===//

class TPUCompilationResultOpAdaptor {
public:
  TPUCompilationResultOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUCompilationResultOpAdaptor(TPUCompilationResultOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUCompilationResultOp : public ::mlir::Op<TPUCompilationResultOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUCompilationResultOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUCompilationResult");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUCompilationResultOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUCompileMlirAndExecuteOp declarations
//===----------------------------------------------------------------------===//

class TPUCompileMlirAndExecuteOpAdaptor {
public:
  TPUCompileMlirAndExecuteOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUCompileMlirAndExecuteOpAdaptor(TPUCompileMlirAndExecuteOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange args();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr mlir_module();
  ::mlir::StringAttr metadata();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUCompileMlirAndExecuteOp : public ::mlir::Op<TPUCompileMlirAndExecuteOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUCompileMlirAndExecuteOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("mlir_module"), ::llvm::StringRef("metadata"), ::llvm::StringRef("Targs"), ::llvm::StringRef("Tresults")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier mlir_moduleAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier mlir_moduleAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier metadataAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier metadataAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TargsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TargsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TresultsAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TresultsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUCompileMlirAndExecute");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range args();
  ::mlir::MutableOperandRange argsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range results();
  ::mlir::StringAttr mlir_moduleAttr();
  ::llvm::StringRef mlir_module();
  ::mlir::StringAttr metadataAttr();
  ::llvm::StringRef metadata();
  mlir::OperandElementTypeRange Targs();
  mlir::ResultElementTypeRange Tresults();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void mlir_moduleAttr(::mlir::StringAttr attr);
  void metadataAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange args, ::mlir::StringAttr mlir_module, ::mlir::StringAttr metadata);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange args, ::llvm::StringRef mlir_module, ::llvm::StringRef metadata);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUCompileMlirAndExecuteOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUCompileSucceededAssertOp declarations
//===----------------------------------------------------------------------===//

class TPUCompileSucceededAssertOpAdaptor {
public:
  TPUCompileSucceededAssertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUCompileSucceededAssertOpAdaptor(TPUCompileSucceededAssertOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value compilation_status();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUCompileSucceededAssertOp : public ::mlir::Op<TPUCompileSucceededAssertOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUCompileSucceededAssertOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUCompileSucceededAssert");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value compilation_status();
  ::mlir::MutableOperandRange compilation_statusMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value compilation_status);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value compilation_status);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUCompileSucceededAssertOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUCopyWithLayoutOp declarations
//===----------------------------------------------------------------------===//

class TPUCopyWithLayoutOpAdaptor {
public:
  TPUCopyWithLayoutOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUCopyWithLayoutOpAdaptor(TPUCopyWithLayoutOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value layout();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUCopyWithLayoutOp : public ::mlir::Op<TPUCopyWithLayoutOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUCopyWithLayoutOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUCopyWithLayout");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value layout();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange layoutMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value layout);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value layout);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUCopyWithLayoutOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUEmbeddingActivationsOp declarations
//===----------------------------------------------------------------------===//

class TPUEmbeddingActivationsOpAdaptor {
public:
  TPUEmbeddingActivationsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUEmbeddingActivationsOpAdaptor(TPUEmbeddingActivationsOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value embedding_variable();
  ::mlir::Value sliced_activations();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr table_id();
  ::mlir::IntegerAttr lookup_id();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUEmbeddingActivationsOp : public ::mlir::Op<TPUEmbeddingActivationsOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUEmbeddingActivationsOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("table_id"), ::llvm::StringRef("lookup_id")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier table_idAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier table_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier lookup_idAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier lookup_idAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUEmbeddingActivations");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value embedding_variable();
  ::mlir::Value sliced_activations();
  ::mlir::MutableOperandRange embedding_variableMutable();
  ::mlir::MutableOperandRange sliced_activationsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr table_idAttr();
  uint64_t table_id();
  ::mlir::IntegerAttr lookup_idAttr();
  uint64_t lookup_id();
  void table_idAttr(::mlir::IntegerAttr attr);
  void lookup_idAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, ::mlir::IntegerAttr table_id, ::mlir::IntegerAttr lookup_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, ::mlir::IntegerAttr table_id, ::mlir::IntegerAttr lookup_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, uint64_t table_id, uint64_t lookup_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, uint64_t table_id, uint64_t lookup_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUEmbeddingActivationsOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUExecuteAndUpdateVariablesOp declarations
//===----------------------------------------------------------------------===//

class TPUExecuteAndUpdateVariablesOpAdaptor {
public:
  TPUExecuteAndUpdateVariablesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUExecuteAndUpdateVariablesOpAdaptor(TPUExecuteAndUpdateVariablesOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange args();
  ::mlir::Value key();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr device_var_reads_indices();
  ::mlir::ArrayAttr device_var_updates_indices();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUExecuteAndUpdateVariablesOp : public ::mlir::Op<TPUExecuteAndUpdateVariablesOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUExecuteAndUpdateVariablesOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("device_var_reads_indices"), ::llvm::StringRef("device_var_updates_indices"), ::llvm::StringRef("Targs"), ::llvm::StringRef("Tresults")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier device_var_reads_indicesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier device_var_reads_indicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier device_var_updates_indicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier device_var_updates_indicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TargsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TargsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TresultsAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TresultsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUExecuteAndUpdateVariables");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range args();
  ::mlir::Value key();
  ::mlir::MutableOperandRange argsMutable();
  ::mlir::MutableOperandRange keyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range results();
  ::mlir::ArrayAttr device_var_reads_indicesAttr();
  ::mlir::ArrayAttr device_var_reads_indices();
  ::mlir::ArrayAttr device_var_updates_indicesAttr();
  ::mlir::ArrayAttr device_var_updates_indices();
  mlir::OperandElementTypeRange Targs();
  mlir::ResultElementTypeRange Tresults();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void device_var_reads_indicesAttr(::mlir::ArrayAttr attr);
  void device_var_updates_indicesAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange args, ::mlir::Value key, ::mlir::ArrayAttr device_var_reads_indices, ::mlir::ArrayAttr device_var_updates_indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUExecuteAndUpdateVariablesOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUExecuteOp declarations
//===----------------------------------------------------------------------===//

class TPUExecuteOpAdaptor {
public:
  TPUExecuteOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUExecuteOpAdaptor(TPUExecuteOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange args();
  ::mlir::Value key();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUExecuteOp : public ::mlir::Op<TPUExecuteOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUExecuteOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Targs"), ::llvm::StringRef("Tresults")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TargsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TargsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TresultsAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TresultsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUExecute");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range args();
  ::mlir::Value key();
  ::mlir::MutableOperandRange argsMutable();
  ::mlir::MutableOperandRange keyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range results();
  mlir::OperandElementTypeRange Targs();
  mlir::ResultElementTypeRange Tresults();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange args, ::mlir::Value key);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUExecuteOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUGetLayoutOp declarations
//===----------------------------------------------------------------------===//

class TPUGetLayoutOpAdaptor {
public:
  TPUGetLayoutOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUGetLayoutOpAdaptor(TPUGetLayoutOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value cache_key();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr index();
  ::mlir::BoolAttr is_output();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUGetLayoutOp : public ::mlir::Op<TPUGetLayoutOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUGetLayoutOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("index"), ::llvm::StringRef("is_output")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier indexAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier indexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier is_outputAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier is_outputAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUGetLayoutOp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value cache_key();
  ::mlir::MutableOperandRange cache_keyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value layout();
  ::mlir::IntegerAttr indexAttr();
  uint64_t index();
  ::mlir::BoolAttr is_outputAttr();
  bool is_output();
  void indexAttr(::mlir::IntegerAttr attr);
  void is_outputAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type layout, ::mlir::Value cache_key, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_output);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value cache_key, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_output);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type layout, ::mlir::Value cache_key, uint64_t index, bool is_output);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value cache_key, uint64_t index, bool is_output);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUGetLayoutOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUOrdinalSelectorOp declarations
//===----------------------------------------------------------------------===//

class TPUOrdinalSelectorOpAdaptor {
public:
  TPUOrdinalSelectorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUOrdinalSelectorOpAdaptor(TPUOrdinalSelectorOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUOrdinalSelectorOp : public ::mlir::Op<TPUOrdinalSelectorOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUOrdinalSelectorOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUOrdinalSelector");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value device_ordinals();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type device_ordinals);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUOrdinalSelectorOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUPartitionedCallOp declarations
//===----------------------------------------------------------------------===//

class TPUPartitionedCallOpAdaptor {
public:
  TPUPartitionedCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUPartitionedCallOpAdaptor(TPUPartitionedCallOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange args();
  ::mlir::Value device_ordinal();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr f();
  ::mlir::IntegerAttr autotuner_thresh();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUPartitionedCallOp : public ::mlir::Op<TPUPartitionedCallOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::CallOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUPartitionedCallOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("f"), ::llvm::StringRef("autotuner_thresh"), ::llvm::StringRef("Tin"), ::llvm::StringRef("Tout")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier fAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier fAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier autotuner_threshAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier autotuner_threshAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TinAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TinAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier ToutAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier ToutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUPartitionedCall");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range args();
  ::mlir::Value device_ordinal();
  ::mlir::MutableOperandRange argsMutable();
  ::mlir::MutableOperandRange device_ordinalMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::SymbolRefAttr fAttr();
  ::mlir::SymbolRefAttr f();
  ::mlir::IntegerAttr autotuner_threshAttr();
  uint64_t autotuner_thresh();
  mlir::OperandElementTypeRange Tin();
  mlir::ResultElementTypeRange Tout();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void fAttr(::mlir::SymbolRefAttr attr);
  void autotuner_threshAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::Value device_ordinal, ::mlir::SymbolRefAttr f, ::mlir::IntegerAttr autotuner_thresh);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::Value device_ordinal, ::mlir::SymbolRefAttr f, uint64_t autotuner_thresh = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

    // Gets the argument operands to the called function.
    operand_range getArgOperands() { return args(); }

    // Returns the callee of this operation.
    CallInterfaceCallable getCallableForCallee() { return fAttr(); }

    // returns the callee of this operation.
    FuncOp func() {
      return SymbolTable::lookupNearestSymbolFrom<FuncOp>(*this, fAttr());
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUPartitionedCallOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUPartitionedInputOp declarations
//===----------------------------------------------------------------------===//

class TPUPartitionedInputOpAdaptor {
public:
  TPUPartitionedInputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUPartitionedInputOpAdaptor(TPUPartitionedInputOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr partition_dim();
  ::mlir::StringAttr _XlaSharding();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUPartitionedInputOp : public ::mlir::Op<TPUPartitionedInputOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUPartitionedInputOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("partition_dim"), ::llvm::StringRef("_XlaSharding"), ::llvm::StringRef("T"), ::llvm::StringRef("N")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier partition_dimAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier partition_dimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier _XlaShardingAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier _XlaShardingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUPartitionedInput");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::MutableOperandRange inputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr partition_dimAttr();
  uint64_t partition_dim();
  ::mlir::StringAttr _XlaShardingAttr();
  ::llvm::Optional< ::llvm::StringRef > _XlaSharding();
  ::mlir::Type T();
  size_t N();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void partition_dimAttr(::mlir::IntegerAttr attr);
  void _XlaShardingAttr(::mlir::StringAttr attr);
  ::mlir::Attribute remove_XlaShardingAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::IntegerAttr partition_dim, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::IntegerAttr partition_dim, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, uint64_t partition_dim, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, uint64_t partition_dim, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUPartitionedInputOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUPartitionedOutputOp declarations
//===----------------------------------------------------------------------===//

class TPUPartitionedOutputOpAdaptor {
public:
  TPUPartitionedOutputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUPartitionedOutputOpAdaptor(TPUPartitionedOutputOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value inputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr partition_dim();
  ::mlir::StringAttr _XlaSharding();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUPartitionedOutputOp : public ::mlir::Op<TPUPartitionedOutputOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUPartitionedOutputOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("partition_dim"), ::llvm::StringRef("_XlaSharding"), ::llvm::StringRef("T"), ::llvm::StringRef("num_splits")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier partition_dimAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier partition_dimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier _XlaShardingAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier _XlaShardingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier num_splitsAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier num_splitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUPartitionedOutput");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value inputs();
  ::mlir::MutableOperandRange inputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::IntegerAttr partition_dimAttr();
  uint64_t partition_dim();
  ::mlir::StringAttr _XlaShardingAttr();
  ::llvm::Optional< ::llvm::StringRef > _XlaSharding();
  ::mlir::Type T();
  size_t num_splits();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void partition_dimAttr(::mlir::IntegerAttr attr);
  void _XlaShardingAttr(::mlir::StringAttr attr);
  ::mlir::Attribute remove_XlaShardingAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value inputs, ::mlir::IntegerAttr partition_dim, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value inputs, uint64_t partition_dim, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUPartitionedOutputOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReplicateMetadataOp declarations
//===----------------------------------------------------------------------===//

class TPUReplicateMetadataOpAdaptor {
public:
  TPUReplicateMetadataOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUReplicateMetadataOpAdaptor(TPUReplicateMetadataOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr num_replicas();
  ::mlir::IntegerAttr num_cores_per_replica();
  ::mlir::StringAttr topology();
  ::mlir::BoolAttr use_tpu();
  ::mlir::ArrayAttr device_assignment();
  ::mlir::ArrayAttr computation_shape();
  ::mlir::ArrayAttr host_compute_core();
  ::mlir::ArrayAttr padding_map();
  ::mlir::StringAttr step_marker_location();
  ::mlir::BoolAttr allow_soft_placement();
  ::mlir::BoolAttr use_spmd_for_xla_partitioning();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUReplicateMetadataOp : public ::mlir::Op<TPUReplicateMetadataOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUReplicateMetadataOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("num_replicas"), ::llvm::StringRef("num_cores_per_replica"), ::llvm::StringRef("topology"), ::llvm::StringRef("use_tpu"), ::llvm::StringRef("device_assignment"), ::llvm::StringRef("computation_shape"), ::llvm::StringRef("host_compute_core"), ::llvm::StringRef("padding_map"), ::llvm::StringRef("step_marker_location"), ::llvm::StringRef("allow_soft_placement"), ::llvm::StringRef("use_spmd_for_xla_partitioning")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier num_replicasAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier num_replicasAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier num_cores_per_replicaAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier num_cores_per_replicaAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier topologyAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier topologyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier use_tpuAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier use_tpuAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier device_assignmentAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier device_assignmentAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier computation_shapeAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier computation_shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier host_compute_coreAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier host_compute_coreAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  ::mlir::Identifier padding_mapAttrName() {
    return getAttributeNameForIndex(7);
  }
  static ::mlir::Identifier padding_mapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }
  ::mlir::Identifier step_marker_locationAttrName() {
    return getAttributeNameForIndex(8);
  }
  static ::mlir::Identifier step_marker_locationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }
  ::mlir::Identifier allow_soft_placementAttrName() {
    return getAttributeNameForIndex(9);
  }
  static ::mlir::Identifier allow_soft_placementAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }
  ::mlir::Identifier use_spmd_for_xla_partitioningAttrName() {
    return getAttributeNameForIndex(10);
  }
  static ::mlir::Identifier use_spmd_for_xla_partitioningAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUReplicateMetadata");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::IntegerAttr num_replicasAttr();
  uint64_t num_replicas();
  ::mlir::IntegerAttr num_cores_per_replicaAttr();
  uint64_t num_cores_per_replica();
  ::mlir::StringAttr topologyAttr();
  ::llvm::StringRef topology();
  ::mlir::BoolAttr use_tpuAttr();
  bool use_tpu();
  ::mlir::ArrayAttr device_assignmentAttr();
  ::mlir::ArrayAttr device_assignment();
  ::mlir::ArrayAttr computation_shapeAttr();
  ::mlir::ArrayAttr computation_shape();
  ::mlir::ArrayAttr host_compute_coreAttr();
  ::mlir::ArrayAttr host_compute_core();
  ::mlir::ArrayAttr padding_mapAttr();
  ::mlir::ArrayAttr padding_map();
  ::mlir::StringAttr step_marker_locationAttr();
  ::llvm::StringRef step_marker_location();
  ::mlir::BoolAttr allow_soft_placementAttr();
  bool allow_soft_placement();
  ::mlir::BoolAttr use_spmd_for_xla_partitioningAttr();
  bool use_spmd_for_xla_partitioning();
  void num_replicasAttr(::mlir::IntegerAttr attr);
  void num_cores_per_replicaAttr(::mlir::IntegerAttr attr);
  void topologyAttr(::mlir::StringAttr attr);
  void use_tpuAttr(::mlir::BoolAttr attr);
  void device_assignmentAttr(::mlir::ArrayAttr attr);
  void computation_shapeAttr(::mlir::ArrayAttr attr);
  void host_compute_coreAttr(::mlir::ArrayAttr attr);
  void padding_mapAttr(::mlir::ArrayAttr attr);
  void step_marker_locationAttr(::mlir::StringAttr attr);
  void allow_soft_placementAttr(::mlir::BoolAttr attr);
  void use_spmd_for_xla_partitioningAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::IntegerAttr num_replicas, ::mlir::IntegerAttr num_cores_per_replica, ::mlir::StringAttr topology, ::mlir::BoolAttr use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::mlir::StringAttr step_marker_location, ::mlir::BoolAttr allow_soft_placement, ::mlir::BoolAttr use_spmd_for_xla_partitioning);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr num_replicas, ::mlir::IntegerAttr num_cores_per_replica, ::mlir::StringAttr topology, ::mlir::BoolAttr use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::mlir::StringAttr step_marker_location, ::mlir::BoolAttr allow_soft_placement, ::mlir::BoolAttr use_spmd_for_xla_partitioning);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, uint64_t num_replicas, uint64_t num_cores_per_replica, ::llvm::StringRef topology, bool use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::llvm::StringRef step_marker_location = "STEP_MARK_AT_ENTRY", bool allow_soft_placement = false, bool use_spmd_for_xla_partitioning = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t num_replicas, uint64_t num_cores_per_replica, ::llvm::StringRef topology, bool use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::llvm::StringRef step_marker_location = "STEP_MARK_AT_ENTRY", bool allow_soft_placement = false, bool use_spmd_for_xla_partitioning = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 11 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUReplicateMetadataOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReplicatedInputOp declarations
//===----------------------------------------------------------------------===//

class TPUReplicatedInputOpAdaptor {
public:
  TPUReplicatedInputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUReplicatedInputOpAdaptor(TPUReplicatedInputOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr is_mirrored_variable();
  ::mlir::IntegerAttr index();
  ::mlir::BoolAttr is_packed();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUReplicatedInputOp : public ::mlir::Op<TPUReplicatedInputOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUReplicatedInputOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("is_mirrored_variable"), ::llvm::StringRef("index"), ::llvm::StringRef("is_packed"), ::llvm::StringRef("N"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier is_mirrored_variableAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier is_mirrored_variableAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier indexAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier indexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier is_packedAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier is_packedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUReplicatedInput");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::MutableOperandRange inputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr is_mirrored_variableAttr();
  bool is_mirrored_variable();
  ::mlir::IntegerAttr indexAttr();
  uint64_t index();
  ::mlir::BoolAttr is_packedAttr();
  bool is_packed();
  size_t N();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void is_mirrored_variableAttr(::mlir::BoolAttr attr);
  void indexAttr(::mlir::IntegerAttr attr);
  void is_packedAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::BoolAttr is_mirrored_variable, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_packed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::BoolAttr is_mirrored_variable, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_packed);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, bool is_mirrored_variable = false, uint64_t index = -1, bool is_packed = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, bool is_mirrored_variable = false, uint64_t index = -1, bool is_packed = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUReplicatedInputOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReplicatedOutputOp declarations
//===----------------------------------------------------------------------===//

class TPUReplicatedOutputOpAdaptor {
public:
  TPUReplicatedOutputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUReplicatedOutputOpAdaptor(TPUReplicatedOutputOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUReplicatedOutputOp : public ::mlir::Op<TPUReplicatedOutputOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUReplicatedOutputOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("num_replicas")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier num_replicasAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier num_replicasAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUReplicatedOutput");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range outputs();
  ::mlir::Type T();
  size_t num_replicas();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUReplicatedOutputOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReshardVariablesOp declarations
//===----------------------------------------------------------------------===//

class TPUReshardVariablesOpAdaptor {
public:
  TPUReshardVariablesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPUReshardVariablesOpAdaptor(TPUReshardVariablesOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange vars();
  ::mlir::Value new_format_key();
  ::mlir::Value format_state_var();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPUReshardVariablesOp : public ::mlir::Op<TPUReshardVariablesOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPUReshardVariablesOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("N")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPUReshardVariables");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range vars();
  ::mlir::Value new_format_key();
  ::mlir::Value format_state_var();
  ::mlir::MutableOperandRange varsMutable();
  ::mlir::MutableOperandRange new_format_keyMutable();
  ::mlir::MutableOperandRange format_state_varMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  size_t N();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange vars, ::mlir::Value new_format_key, ::mlir::Value format_state_var);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange vars, ::mlir::Value new_format_key, ::mlir::Value format_state_var);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPUReshardVariablesOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPURoundRobinOp declarations
//===----------------------------------------------------------------------===//

class TPURoundRobinOpAdaptor {
public:
  TPURoundRobinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TPURoundRobinOpAdaptor(TPURoundRobinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TPURoundRobinOp : public ::mlir::Op<TPURoundRobinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TPURoundRobinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TPURoundRobin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value device_ordinal();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type device_ordinal);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TPURoundRobinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TakeDatasetOp declarations
//===----------------------------------------------------------------------===//

class TakeDatasetOpAdaptor {
public:
  TakeDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TakeDatasetOpAdaptor(TakeDatasetOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value count();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TakeDatasetOp : public ::mlir::Op<TakeDatasetOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TakeDatasetOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_types"), ::llvm::StringRef("output_shapes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TakeDataset");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_dataset();
  ::mlir::Value count();
  ::mlir::MutableOperandRange input_datasetMutable();
  ::mlir::MutableOperandRange countMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::ArrayAttr output_typesAttr();
  ::mlir::ArrayAttr output_types();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  void output_typesAttr(::mlir::ArrayAttr attr);
  void output_shapesAttr(::mlir::ArrayAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value count, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value count, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TakeDatasetOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TanOp declarations
//===----------------------------------------------------------------------===//

class TanOpAdaptor {
public:
  TanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TanOpAdaptor(TanOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TanOp : public ::mlir::Op<TanOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TanOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Tan");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TanOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TanhGradOp declarations
//===----------------------------------------------------------------------===//

class TanhGradOpAdaptor {
public:
  TanhGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TanhGradOpAdaptor(TanhGradOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TanhGradOp : public ::mlir::Op<TanhGradOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TanhGradOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TanhGrad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value y();
  ::mlir::Value dy();
  ::mlir::MutableOperandRange yMutable();
  ::mlir::MutableOperandRange dyMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TanhGradOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TanhOp declarations
//===----------------------------------------------------------------------===//

class TanhOpAdaptor {
public:
  TanhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TanhOpAdaptor(TanhOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TanhOp : public ::mlir::Op<TanhOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::LayoutAgnostic, ::mlir::OpTrait::TF::SameOperandsAndResultTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TanhOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Tanh");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TanhOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayCloseV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayCloseV3OpAdaptor {
public:
  TensorArrayCloseV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayCloseV3OpAdaptor(TensorArrayCloseV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayCloseV3Op : public ::mlir::Op<TensorArrayCloseV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayCloseV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayCloseV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::MutableOperandRange handleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayCloseV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayConcatV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayConcatV3OpAdaptor {
public:
  TensorArrayConcatV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayConcatV3OpAdaptor(TensorArrayConcatV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute element_shape_except0();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayConcatV3Op : public ::mlir::Op<TensorArrayConcatV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayConcatV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_shape_except0"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_shape_except0AttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_shape_except0AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayConcatV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value value();
  ::mlir::Value lengths();
  ::mlir::Attribute element_shape_except0Attr();
  llvm::Optional<llvm::ArrayRef<int64_t>> element_shape_except0();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void element_shape_except0Attr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Type lengths, ::mlir::Value handle, ::mlir::Value flow_in, ::mlir::Attribute element_shape_except0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, ::mlir::Attribute element_shape_except0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Type lengths, ::mlir::Value handle, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape_except0 = llvm::None);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape_except0 = llvm::None);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayConcatV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayGatherV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayGatherV3OpAdaptor {
public:
  TensorArrayGatherV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayGatherV3OpAdaptor(TensorArrayGatherV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value indices();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute element_shape();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayGatherV3Op : public ::mlir::Op<TensorArrayGatherV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayGatherV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_shape"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_shapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayGatherV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value indices();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value value();
  ::mlir::Attribute element_shapeAttr();
  llvm::Optional<llvm::ArrayRef<int64_t>> element_shape();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void element_shapeAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, ::mlir::Attribute element_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, ::mlir::Attribute element_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape = llvm::None);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape = llvm::None);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayGatherV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayGradV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayGradV3OpAdaptor {
public:
  TensorArrayGradV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayGradV3OpAdaptor(TensorArrayGradV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr source();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayGradV3Op : public ::mlir::Op<TensorArrayGradV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpAsmOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayGradV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("source")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier sourceAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier sourceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayGradV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value grad_handle();
  ::mlir::Value flow_out();
  ::mlir::StringAttr sourceAttr();
  ::llvm::StringRef source();
  void sourceAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type grad_handle, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value flow_in, ::mlir::StringAttr source);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, ::mlir::StringAttr source);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type grad_handle, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value flow_in, ::llvm::StringRef source);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, ::llvm::StringRef source);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayGradV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayReadV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayReadV3OpAdaptor {
public:
  TensorArrayReadV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayReadV3OpAdaptor(TensorArrayReadV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value index();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayReadV3Op : public ::mlir::Op<TensorArrayReadV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayReadV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayReadV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value index();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange indexMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value value();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayReadV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayScatterV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayScatterV3OpAdaptor {
public:
  TensorArrayScatterV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayScatterV3OpAdaptor(TensorArrayScatterV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value indices();
  ::mlir::Value value();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayScatterV3Op : public ::mlir::Op<TensorArrayScatterV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayScatterV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayScatterV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value indices();
  ::mlir::Value value();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange valueMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value flow_out();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value value, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value value, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayScatterV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArraySizeV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArraySizeV3OpAdaptor {
public:
  TensorArraySizeV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArraySizeV3OpAdaptor(TensorArraySizeV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArraySizeV3Op : public ::mlir::Op<TensorArraySizeV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArraySizeV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArraySizeV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value size();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type size, ::mlir::Value handle, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArraySizeV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArraySplitV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArraySplitV3OpAdaptor {
public:
  TensorArraySplitV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArraySplitV3OpAdaptor(TensorArraySplitV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value value();
  ::mlir::Value lengths();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArraySplitV3Op : public ::mlir::Op<TensorArraySplitV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArraySplitV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArraySplitV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value value();
  ::mlir::Value lengths();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange valueMutable();
  ::mlir::MutableOperandRange lengthsMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value flow_out();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value value, ::mlir::Value lengths, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value value, ::mlir::Value lengths, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArraySplitV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayV3OpAdaptor {
public:
  TensorArrayV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayV3OpAdaptor(TensorArrayV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::TypeAttr dtype();
  ::mlir::Attribute element_shape();
  ::mlir::BoolAttr dynamic_size();
  ::mlir::BoolAttr clear_after_read();
  ::mlir::BoolAttr identical_element_shapes();
  ::mlir::StringAttr tensor_array_name();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayV3Op : public ::mlir::Op<TensorArrayV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpAsmOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dtype"), ::llvm::StringRef("element_shape"), ::llvm::StringRef("dynamic_size"), ::llvm::StringRef("clear_after_read"), ::llvm::StringRef("identical_element_shapes"), ::llvm::StringRef("tensor_array_name")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier element_shapeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier element_shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dynamic_sizeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dynamic_sizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier clear_after_readAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier clear_after_readAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier identical_element_shapesAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier identical_element_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier tensor_array_nameAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier tensor_array_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value size();
  ::mlir::MutableOperandRange sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value flow();
  ::mlir::TypeAttr dtypeAttr();
  ::mlir::Type dtype();
  ::mlir::Attribute element_shapeAttr();
  llvm::Optional<llvm::ArrayRef<int64_t>> element_shape();
  ::mlir::BoolAttr dynamic_sizeAttr();
  bool dynamic_size();
  ::mlir::BoolAttr clear_after_readAttr();
  bool clear_after_read();
  ::mlir::BoolAttr identical_element_shapesAttr();
  bool identical_element_shapes();
  ::mlir::StringAttr tensor_array_nameAttr();
  ::llvm::StringRef tensor_array_name();
  void dtypeAttr(::mlir::TypeAttr attr);
  void element_shapeAttr(::mlir::Attribute attr);
  void dynamic_sizeAttr(::mlir::BoolAttr attr);
  void clear_after_readAttr(::mlir::BoolAttr attr);
  void identical_element_shapesAttr(::mlir::BoolAttr attr);
  void tensor_array_nameAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type flow, ::mlir::Value size, ::mlir::TypeAttr dtype, ::mlir::Attribute element_shape, ::mlir::BoolAttr dynamic_size, ::mlir::BoolAttr clear_after_read, ::mlir::BoolAttr identical_element_shapes, ::mlir::StringAttr tensor_array_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value size, ::mlir::TypeAttr dtype, ::mlir::Attribute element_shape, ::mlir::BoolAttr dynamic_size, ::mlir::BoolAttr clear_after_read, ::mlir::BoolAttr identical_element_shapes, ::mlir::StringAttr tensor_array_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type flow, ::mlir::Value size, ::mlir::Type dtype, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape, bool dynamic_size, bool clear_after_read, bool identical_element_shapes, ::llvm::StringRef tensor_array_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value size, ::mlir::Type dtype, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape, bool dynamic_size, bool clear_after_read, bool identical_element_shapes, ::llvm::StringRef tensor_array_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayWriteV3Op declarations
//===----------------------------------------------------------------------===//

class TensorArrayWriteV3OpAdaptor {
public:
  TensorArrayWriteV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorArrayWriteV3OpAdaptor(TensorArrayWriteV3Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value index();
  ::mlir::Value value();
  ::mlir::Value flow_in();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorArrayWriteV3Op : public ::mlir::Op<TensorArrayWriteV3Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorArrayWriteV3OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorArrayWriteV3");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value handle();
  ::mlir::Value index();
  ::mlir::Value value();
  ::mlir::Value flow_in();
  ::mlir::MutableOperandRange handleMutable();
  ::mlir::MutableOperandRange indexMutable();
  ::mlir::MutableOperandRange valueMutable();
  ::mlir::MutableOperandRange flow_inMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value flow_out();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value value, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value value, ::mlir::Value flow_in);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorArrayWriteV3Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListConcatV2Op declarations
//===----------------------------------------------------------------------===//

class TensorListConcatV2OpAdaptor {
public:
  TensorListConcatV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListConcatV2OpAdaptor(TensorListConcatV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value element_shape();
  ::mlir::Value leading_dims();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListConcatV2Op : public ::mlir::Op<TensorListConcatV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListConcatV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_type"), ::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_typeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListConcatV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value element_shape();
  ::mlir::Value leading_dims();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange element_shapeMutable();
  ::mlir::MutableOperandRange leading_dimsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value lengths();
  ::mlir::Type shape_type();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Type lengths, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::Value leading_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::Value leading_dims);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListConcatV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListElementShapeOp declarations
//===----------------------------------------------------------------------===//

class TensorListElementShapeOpAdaptor {
public:
  TensorListElementShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListElementShapeOpAdaptor(TensorListElementShapeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListElementShapeOp : public ::mlir::Op<TensorListElementShapeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListElementShapeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_typeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListElementShape");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::MutableOperandRange input_handleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value element_shape();
  ::mlir::Type shape_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type element_shape, ::mlir::Value input_handle);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListElementShapeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListFromTensorOp declarations
//===----------------------------------------------------------------------===//

class TensorListFromTensorOpAdaptor {
public:
  TensorListFromTensorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListFromTensorOpAdaptor(TensorListFromTensorOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value element_shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListFromTensorOp : public ::mlir::Op<TensorListFromTensorOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListFromTensorOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_dtype"), ::llvm::StringRef("shape_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier shape_typeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier shape_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListFromTensor");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value element_shape();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange element_shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_handle();
  ::mlir::Type element_dtype();
  ::mlir::Type shape_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value tensor, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListFromTensorOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListGatherOp declarations
//===----------------------------------------------------------------------===//

class TensorListGatherOpAdaptor {
public:
  TensorListGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListGatherOpAdaptor(TensorListGatherOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value indices();
  ::mlir::Value element_shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListGatherOp : public ::mlir::Op<TensorListGatherOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListGatherOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListGather");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value indices();
  ::mlir::Value element_shape();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange element_shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value values();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values, ::mlir::Value input_handle, ::mlir::Value indices, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value indices, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListGatherOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListGetItemOp declarations
//===----------------------------------------------------------------------===//

class TensorListGetItemOpAdaptor {
public:
  TensorListGetItemOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListGetItemOpAdaptor(TensorListGetItemOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value index();
  ::mlir::Value element_shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListGetItemOp : public ::mlir::Op<TensorListGetItemOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListGetItemOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListGetItem");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value index();
  ::mlir::Value element_shape();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange indexMutable();
  ::mlir::MutableOperandRange element_shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value item();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type item, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListGetItemOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListLengthOp declarations
//===----------------------------------------------------------------------===//

class TensorListLengthOpAdaptor {
public:
  TensorListLengthOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListLengthOpAdaptor(TensorListLengthOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListLengthOp : public ::mlir::Op<TensorListLengthOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListLengthOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListLength");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::MutableOperandRange input_handleMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value length();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type length, ::mlir::Value input_handle);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListLengthOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListPopBackOp declarations
//===----------------------------------------------------------------------===//

class TensorListPopBackOpAdaptor {
public:
  TensorListPopBackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListPopBackOpAdaptor(TensorListPopBackOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value element_shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListPopBackOp : public ::mlir::Op<TensorListPopBackOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListPopBackOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListPopBack");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value element_shape();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange element_shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_handle();
  ::mlir::Value tensor();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Type tensor, ::mlir::Value input_handle, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListPopBackOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListPushBackOp declarations
//===----------------------------------------------------------------------===//

class TensorListPushBackOpAdaptor {
public:
  TensorListPushBackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListPushBackOpAdaptor(TensorListPushBackOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value tensor();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListPushBackOp : public ::mlir::Op<TensorListPushBackOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListPushBackOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListPushBack");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value tensor();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange tensorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_handle();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value tensor);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value tensor);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListPushBackOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListReserveOp declarations
//===----------------------------------------------------------------------===//

class TensorListReserveOpAdaptor {
public:
  TensorListReserveOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListReserveOpAdaptor(TensorListReserveOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value element_shape();
  ::mlir::Value num_elements();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListReserveOp : public ::mlir::Op<TensorListReserveOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListReserveOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape_type"), ::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shape_typeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shape_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListReserve");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value element_shape();
  ::mlir::Value num_elements();
  ::mlir::MutableOperandRange element_shapeMutable();
  ::mlir::MutableOperandRange num_elementsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::Type shape_type();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value element_shape, ::mlir::Value num_elements);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value element_shape, ::mlir::Value num_elements);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // Returns type of the TensorList element produced by this op.
    TensorType element_type() { return handle_dtype().getSubtypes()[0]; }

    // Returns data type of the result handle. Returned type contains type of
    // the TensorList element as a subtype.
    VariantType handle_dtype() {
      return getElementTypeOrSelf(handle().getType()).cast<TF::VariantType>();
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListReserveOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListResizeOp declarations
//===----------------------------------------------------------------------===//

class TensorListResizeOpAdaptor {
public:
  TensorListResizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListResizeOpAdaptor(TensorListResizeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListResizeOp : public ::mlir::Op<TensorListResizeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListResizeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListResize");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value size();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_handle();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value size);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListResizeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListScatterIntoExistingListOp declarations
//===----------------------------------------------------------------------===//

class TensorListScatterIntoExistingListOpAdaptor {
public:
  TensorListScatterIntoExistingListOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListScatterIntoExistingListOpAdaptor(TensorListScatterIntoExistingListOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListScatterIntoExistingListOp : public ::mlir::Op<TensorListScatterIntoExistingListOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListScatterIntoExistingListOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListScatterIntoExistingList");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_handle();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value tensor, ::mlir::Value indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value tensor, ::mlir::Value indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListScatterIntoExistingListOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListSetItemOp declarations
//===----------------------------------------------------------------------===//

class TensorListSetItemOpAdaptor {
public:
  TensorListSetItemOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListSetItemOpAdaptor(TensorListSetItemOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value index();
  ::mlir::Value item();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListSetItemOp : public ::mlir::Op<TensorListSetItemOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListSetItemOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListSetItem");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value index();
  ::mlir::Value item();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange indexMutable();
  ::mlir::MutableOperandRange itemMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_handle();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value item);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value item);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListSetItemOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListStackOp declarations
//===----------------------------------------------------------------------===//

class TensorListStackOpAdaptor {
public:
  TensorListStackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorListStackOpAdaptor(TensorListStackOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value element_shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr num_elements();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorListStackOp : public ::mlir::Op<TensorListStackOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorListStackOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("num_elements"), ::llvm::StringRef("element_dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier num_elementsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier num_elementsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier element_dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier element_dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorListStack");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input_handle();
  ::mlir::Value element_shape();
  ::mlir::MutableOperandRange input_handleMutable();
  ::mlir::MutableOperandRange element_shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value tensor();
  ::mlir::IntegerAttr num_elementsAttr();
  uint64_t num_elements();
  ::mlir::Type element_dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void num_elementsAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::IntegerAttr num_elements);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::IntegerAttr num_elements);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Value input_handle, ::mlir::Value element_shape, uint64_t num_elements = -1);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape, uint64_t num_elements = -1);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorListStackOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterAddOp declarations
//===----------------------------------------------------------------------===//

class TensorScatterAddOpAdaptor {
public:
  TensorScatterAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorScatterAddOpAdaptor(TensorScatterAddOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorScatterAddOp : public ::mlir::Op<TensorScatterAddOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorScatterAddOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorScatterAdd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value tensor, Value indices, Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorScatterAddOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterMaxOp declarations
//===----------------------------------------------------------------------===//

class TensorScatterMaxOpAdaptor {
public:
  TensorScatterMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorScatterMaxOpAdaptor(TensorScatterMaxOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorScatterMaxOp : public ::mlir::Op<TensorScatterMaxOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorScatterMaxOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorScatterMax");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorScatterMaxOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterMinOp declarations
//===----------------------------------------------------------------------===//

class TensorScatterMinOpAdaptor {
public:
  TensorScatterMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorScatterMinOpAdaptor(TensorScatterMinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorScatterMinOp : public ::mlir::Op<TensorScatterMinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorScatterMinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorScatterMin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorScatterMinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterSubOp declarations
//===----------------------------------------------------------------------===//

class TensorScatterSubOpAdaptor {
public:
  TensorScatterSubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorScatterSubOpAdaptor(TensorScatterSubOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorScatterSubOp : public ::mlir::Op<TensorScatterSubOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorScatterSubOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorScatterSub");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorScatterSubOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterUpdateOp declarations
//===----------------------------------------------------------------------===//

class TensorScatterUpdateOpAdaptor {
public:
  TensorScatterUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorScatterUpdateOpAdaptor(TensorScatterUpdateOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorScatterUpdateOp : public ::mlir::Op<TensorScatterUpdateOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorScatterUpdateOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorScatterUpdate");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value tensor();
  ::mlir::Value indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value tensor, Value indices, Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorScatterUpdateOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorSliceDatasetOp declarations
//===----------------------------------------------------------------------===//

class TensorSliceDatasetOpAdaptor {
public:
  TensorSliceDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorSliceDatasetOpAdaptor(TensorSliceDatasetOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange components();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr is_files();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorSliceDatasetOp : public ::mlir::Op<TensorSliceDatasetOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorSliceDatasetOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_shapes"), ::llvm::StringRef("is_files"), ::llvm::StringRef("Toutput_types")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier is_filesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier is_filesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier Toutput_typesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier Toutput_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorSliceDataset");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range components();
  ::mlir::MutableOperandRange componentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value handle();
  ::mlir::ArrayAttr output_shapesAttr();
  ::mlir::ArrayAttr output_shapes();
  ::mlir::BoolAttr is_filesAttr();
  bool is_files();
  mlir::OperandElementTypeRange Toutput_types();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void output_shapesAttr(::mlir::ArrayAttr attr);
  void is_filesAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::ValueRange components, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr is_files);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange components, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr is_files);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::ValueRange components, ::mlir::ArrayAttr output_shapes, bool is_files = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange components, ::mlir::ArrayAttr output_shapes, bool is_files = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorSliceDatasetOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorStridedSliceUpdateOp declarations
//===----------------------------------------------------------------------===//

class TensorStridedSliceUpdateOpAdaptor {
public:
  TensorStridedSliceUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TensorStridedSliceUpdateOpAdaptor(TensorStridedSliceUpdateOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::Value value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr begin_mask();
  ::mlir::IntegerAttr end_mask();
  ::mlir::IntegerAttr ellipsis_mask();
  ::mlir::IntegerAttr new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_mask();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TensorStridedSliceUpdateOp : public ::mlir::Op<TensorStridedSliceUpdateOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TensorStridedSliceUpdateOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("begin_mask"), ::llvm::StringRef("end_mask"), ::llvm::StringRef("ellipsis_mask"), ::llvm::StringRef("new_axis_mask"), ::llvm::StringRef("shrink_axis_mask"), ::llvm::StringRef("Index"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier begin_maskAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier begin_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier end_maskAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier end_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier ellipsis_maskAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier ellipsis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier new_axis_maskAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier new_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier shrink_axis_maskAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier shrink_axis_maskAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier IndexAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier IndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TensorStridedSliceUpdate");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value begin();
  ::mlir::Value end();
  ::mlir::Value strides();
  ::mlir::Value value();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange beginMutable();
  ::mlir::MutableOperandRange endMutable();
  ::mlir::MutableOperandRange stridesMutable();
  ::mlir::MutableOperandRange valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr begin_maskAttr();
  uint64_t begin_mask();
  ::mlir::IntegerAttr end_maskAttr();
  uint64_t end_mask();
  ::mlir::IntegerAttr ellipsis_maskAttr();
  uint64_t ellipsis_mask();
  ::mlir::IntegerAttr new_axis_maskAttr();
  uint64_t new_axis_mask();
  ::mlir::IntegerAttr shrink_axis_maskAttr();
  uint64_t shrink_axis_mask();
  ::mlir::Type Index();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void begin_maskAttr(::mlir::IntegerAttr attr);
  void end_maskAttr(::mlir::IntegerAttr attr);
  void ellipsis_maskAttr(::mlir::IntegerAttr attr);
  void new_axis_maskAttr(::mlir::IntegerAttr attr);
  void shrink_axis_maskAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask = 0, uint64_t end_mask = 0, uint64_t ellipsis_mask = 0, uint64_t new_axis_mask = 0, uint64_t shrink_axis_mask = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TensorStridedSliceUpdateOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TileOp declarations
//===----------------------------------------------------------------------===//

class TileOpAdaptor {
public:
  TileOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TileOpAdaptor(TileOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value multiples();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TileOp : public ::mlir::Op<TileOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TileOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tmultiples")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TmultiplesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TmultiplesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Tile");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value multiples();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange multiplesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tmultiples();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value multiples);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value multiples);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TileOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TimestampOp declarations
//===----------------------------------------------------------------------===//

class TimestampOpAdaptor {
public:
  TimestampOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TimestampOpAdaptor(TimestampOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TimestampOp : public ::mlir::Op<TimestampOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TimestampOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Timestamp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value ts();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type ts);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TimestampOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ToBoolOp declarations
//===----------------------------------------------------------------------===//

class ToBoolOpAdaptor {
public:
  ToBoolOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ToBoolOpAdaptor(ToBoolOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ToBoolOp : public ::mlir::Op<ToBoolOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::InferTypeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ToBoolOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ToBool");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  static ::mlir::LogicalResult inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // InferTypeOpInterface:
    static bool isCompatibleReturnTypes(TypeRange l, TypeRange r) {
      return ArraysAreCastCompatible(l, r);
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ToBoolOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TopKUniqueOp declarations
//===----------------------------------------------------------------------===//

class TopKUniqueOpAdaptor {
public:
  TopKUniqueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TopKUniqueOpAdaptor(TopKUniqueOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr k();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TopKUniqueOp : public ::mlir::Op<TopKUniqueOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TopKUniqueOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("k")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier kAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier kAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TopKUnique");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value topk();
  ::mlir::Value topk_indices();
  ::mlir::IntegerAttr kAttr();
  uint64_t k();
  void kAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type topk, ::mlir::Type topk_indices, ::mlir::Value input, ::mlir::IntegerAttr k);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr k);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type topk, ::mlir::Type topk_indices, ::mlir::Value input, uint64_t k);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t k);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TopKUniqueOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TopKV2Op declarations
//===----------------------------------------------------------------------===//

class TopKV2OpAdaptor {
public:
  TopKV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TopKV2OpAdaptor(TopKV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value k();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr sorted();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TopKV2Op : public ::mlir::Op<TopKV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TopKV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("sorted"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier sortedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier sortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TopKV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value k();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange kMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value values();
  ::mlir::Value indices();
  ::mlir::BoolAttr sortedAttr();
  bool sorted();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void sortedAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values, ::mlir::Type indices, ::mlir::Value input, ::mlir::Value k, ::mlir::BoolAttr sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value k, ::mlir::BoolAttr sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values, ::mlir::Type indices, ::mlir::Value input, ::mlir::Value k, bool sorted = true);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value k, bool sorted = true);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TopKV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TopKWithUniqueOp declarations
//===----------------------------------------------------------------------===//

class TopKWithUniqueOpAdaptor {
public:
  TopKWithUniqueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TopKWithUniqueOpAdaptor(TopKWithUniqueOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr k();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TopKWithUniqueOp : public ::mlir::Op<TopKWithUniqueOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TopKWithUniqueOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("k")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier kAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier kAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TopKWithUnique");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value topk();
  ::mlir::Value topk_indices();
  ::mlir::IntegerAttr kAttr();
  uint64_t k();
  void kAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type topk, ::mlir::Type topk_indices, ::mlir::Value input, ::mlir::IntegerAttr k);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr k);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type topk, ::mlir::Type topk_indices, ::mlir::Value input, uint64_t k);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t k);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TopKWithUniqueOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TransposeOp declarations
//===----------------------------------------------------------------------===//

class TransposeOpAdaptor {
public:
  TransposeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TransposeOpAdaptor(TransposeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value perm();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TransposeOp : public ::mlir::Op<TransposeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TransposeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tperm")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TpermAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TpermAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Transpose");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value perm();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange permMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  ::mlir::Type Tperm();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value perm);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::Value perm);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value perm);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TransposeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TridiagonalSolveOp declarations
//===----------------------------------------------------------------------===//

class TridiagonalSolveOpAdaptor {
public:
  TridiagonalSolveOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TridiagonalSolveOpAdaptor(TridiagonalSolveOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value diagonals();
  ::mlir::Value rhs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr partial_pivoting();
  ::mlir::BoolAttr perturb_singular();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TridiagonalSolveOp : public ::mlir::Op<TridiagonalSolveOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TridiagonalSolveOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("partial_pivoting"), ::llvm::StringRef("perturb_singular"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier partial_pivotingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier partial_pivotingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier perturb_singularAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier perturb_singularAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TridiagonalSolve");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value diagonals();
  ::mlir::Value rhs();
  ::mlir::MutableOperandRange diagonalsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::BoolAttr partial_pivotingAttr();
  bool partial_pivoting();
  ::mlir::BoolAttr perturb_singularAttr();
  bool perturb_singular();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void partial_pivotingAttr(::mlir::BoolAttr attr);
  void perturb_singularAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonals, ::mlir::Value rhs, ::mlir::BoolAttr partial_pivoting, ::mlir::BoolAttr perturb_singular);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonals, ::mlir::Value rhs, ::mlir::BoolAttr partial_pivoting, ::mlir::BoolAttr perturb_singular);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonals, ::mlir::Value rhs, bool partial_pivoting = true, bool perturb_singular = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonals, ::mlir::Value rhs, bool partial_pivoting = true, bool perturb_singular = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TridiagonalSolveOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TruncateDivOp declarations
//===----------------------------------------------------------------------===//

class TruncateDivOpAdaptor {
public:
  TruncateDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TruncateDivOpAdaptor(TruncateDivOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TruncateDivOp : public ::mlir::Op<TruncateDivOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TruncateDivOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TruncateDiv");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TruncateDivOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TruncateModOp declarations
//===----------------------------------------------------------------------===//

class TruncateModOpAdaptor {
public:
  TruncateModOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TruncateModOpAdaptor(TruncateModOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TruncateModOp : public ::mlir::Op<TruncateModOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::OpTrait::TF::SameOperandsAndResultElementTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TruncateModOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TruncateMod");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TruncateModOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TruncatedNormalOp declarations
//===----------------------------------------------------------------------===//

class TruncatedNormalOpAdaptor {
public:
  TruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  TruncatedNormalOpAdaptor(TruncatedNormalOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr seed();
  ::mlir::IntegerAttr seed2();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class TruncatedNormalOp : public ::mlir::Op<TruncatedNormalOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::TF::CannotDuplicate, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TruncatedNormalOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("seed"), ::llvm::StringRef("seed2"), ::llvm::StringRef("T"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier seedAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier seedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier seed2AttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier seed2AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.TruncatedNormal");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value shape();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::IntegerAttr seedAttr();
  uint64_t seed();
  ::mlir::IntegerAttr seed2Attr();
  uint64_t seed2();
  ::mlir::Type T();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void seedAttr(::mlir::IntegerAttr attr);
  void seed2Attr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, uint64_t seed = 0, uint64_t seed2 = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::TruncatedNormalOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UncompressElementOp declarations
//===----------------------------------------------------------------------===//

class UncompressElementOpAdaptor {
public:
  UncompressElementOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UncompressElementOpAdaptor(UncompressElementOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value compressed();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UncompressElementOp : public ::mlir::Op<UncompressElementOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UncompressElementOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("output_shapes"), ::llvm::StringRef("output_types")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier output_typesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier output_typesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.UncompressElement");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value compressed();
  ::mlir::MutableOperandRange compressedMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range components();
  mlir::TF::ResultShapeRange output_shapes();
  mlir::ResultElementTypeRange output_types();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value compressed);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UncompressElementOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UniqueOp declarations
//===----------------------------------------------------------------------===//

class UniqueOpAdaptor {
public:
  UniqueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UniqueOpAdaptor(UniqueOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UniqueOp : public ::mlir::Op<UniqueOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UniqueOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("out_idx")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier out_idxAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier out_idxAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Unique");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Value idx();
  ::mlir::Type T();
  ::mlir::Type out_idx();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type idx, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UniqueOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnpackOp declarations
//===----------------------------------------------------------------------===//

class UnpackOpAdaptor {
public:
  UnpackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UnpackOpAdaptor(UnpackOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr axis();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UnpackOp : public ::mlir::Op<UnpackOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UnpackOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("axis"), ::llvm::StringRef("T"), ::llvm::StringRef("num")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier axisAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier axisAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier numAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier numAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Unpack");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value value();
  ::mlir::MutableOperandRange valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::IntegerAttr axisAttr();
  uint64_t axis();
  ::mlir::Type T();
  size_t num();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void axisAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value value, ::mlir::IntegerAttr axis);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value value, uint64_t axis = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UnpackOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentMaxOp declarations
//===----------------------------------------------------------------------===//

class UnsortedSegmentMaxOpAdaptor {
public:
  UnsortedSegmentMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UnsortedSegmentMaxOpAdaptor(UnsortedSegmentMaxOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UnsortedSegmentMaxOp : public ::mlir::Op<UnsortedSegmentMaxOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UnsortedSegmentMaxOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices"), ::llvm::StringRef("Tnumsegments")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TnumsegmentsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TnumsegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.UnsortedSegmentMax");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange num_segmentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  ::mlir::Type Tnumsegments();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UnsortedSegmentMaxOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentMinOp declarations
//===----------------------------------------------------------------------===//

class UnsortedSegmentMinOpAdaptor {
public:
  UnsortedSegmentMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UnsortedSegmentMinOpAdaptor(UnsortedSegmentMinOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UnsortedSegmentMinOp : public ::mlir::Op<UnsortedSegmentMinOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UnsortedSegmentMinOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices"), ::llvm::StringRef("Tnumsegments")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TnumsegmentsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TnumsegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.UnsortedSegmentMin");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange num_segmentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  ::mlir::Type Tnumsegments();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UnsortedSegmentMinOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentProdOp declarations
//===----------------------------------------------------------------------===//

class UnsortedSegmentProdOpAdaptor {
public:
  UnsortedSegmentProdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UnsortedSegmentProdOpAdaptor(UnsortedSegmentProdOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UnsortedSegmentProdOp : public ::mlir::Op<UnsortedSegmentProdOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UnsortedSegmentProdOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices"), ::llvm::StringRef("Tnumsegments")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TnumsegmentsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TnumsegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.UnsortedSegmentProd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange num_segmentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  ::mlir::Type Tnumsegments();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UnsortedSegmentProdOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentSumOp declarations
//===----------------------------------------------------------------------===//

class UnsortedSegmentSumOpAdaptor {
public:
  UnsortedSegmentSumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UnsortedSegmentSumOpAdaptor(UnsortedSegmentSumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UnsortedSegmentSumOp : public ::mlir::Op<UnsortedSegmentSumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UnsortedSegmentSumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices"), ::llvm::StringRef("Tnumsegments")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TnumsegmentsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TnumsegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.UnsortedSegmentSum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value data();
  ::mlir::Value segment_ids();
  ::mlir::Value num_segments();
  ::mlir::MutableOperandRange dataMutable();
  ::mlir::MutableOperandRange segment_idsMutable();
  ::mlir::MutableOperandRange num_segmentsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  ::mlir::Type Tnumsegments();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UnsortedSegmentSumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UpperBoundOp declarations
//===----------------------------------------------------------------------===//

class UpperBoundOpAdaptor {
public:
  UpperBoundOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  UpperBoundOpAdaptor(UpperBoundOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value sorted_inputs();
  ::mlir::Value values();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class UpperBoundOp : public ::mlir::Op<UpperBoundOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UpperBoundOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("out_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier out_typeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier out_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.UpperBound");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value sorted_inputs();
  ::mlir::Value values();
  ::mlir::MutableOperandRange sorted_inputsMutable();
  ::mlir::MutableOperandRange valuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type out_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value sorted_inputs, ::mlir::Value values);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sorted_inputs, ::mlir::Value values);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::UpperBoundOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VarHandleOp declarations
//===----------------------------------------------------------------------===//

class VarHandleOpAdaptor {
public:
  VarHandleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  VarHandleOpAdaptor(VarHandleOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr container();
  ::mlir::StringAttr shared_name();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class VarHandleOp : public ::mlir::Op<VarHandleOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ResourceHandleAllocatorInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = VarHandleOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("container"), ::llvm::StringRef("shared_name"), ::llvm::StringRef("dtype"), ::llvm::StringRef("shape")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier containerAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier containerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier shared_nameAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier shared_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier shapeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.VarHandleOp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value resource();
  ::mlir::StringAttr containerAttr();
  ::llvm::StringRef container();
  ::mlir::StringAttr shared_nameAttr();
  ::llvm::StringRef shared_name();
  ::mlir::Type dtype();
  ShapedType shape();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void containerAttr(::mlir::StringAttr attr);
  void shared_nameAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resource, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resource, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  llvm::SmallVector<ResourceHandleValueAndId, 4> GetResourceHandleValueAndIdList(llvm::SmallDenseMap<ResourceHandle, int64_t>&resource_handle_id_map, int64_t&next_id);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    TensorType resource_subtype() { return resource_type().getSubtypes()[0]; }

    ResourceType resource_type() {
      return getElementTypeOrSelf(resource()).cast<TF::ResourceType>();
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::VarHandleOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VarIsInitializedOp declarations
//===----------------------------------------------------------------------===//

class VarIsInitializedOpAdaptor {
public:
  VarIsInitializedOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  VarIsInitializedOpAdaptor(VarIsInitializedOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class VarIsInitializedOp : public ::mlir::Op<VarIsInitializedOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = VarIsInitializedOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.VarIsInitializedOp");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value resource();
  ::mlir::MutableOperandRange resourceMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value is_initialized();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type is_initialized, ::mlir::Value resource);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::VarIsInitializedOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VariableOp declarations
//===----------------------------------------------------------------------===//

class VariableOpAdaptor {
public:
  VariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  VariableOpAdaptor(VariableOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute shape();
  ::mlir::StringAttr container();
  ::mlir::StringAttr shared_name();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class VariableOp : public ::mlir::Op<VariableOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = VariableOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape"), ::llvm::StringRef("container"), ::llvm::StringRef("shared_name"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier containerAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier containerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier shared_nameAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier shared_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Variable");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value ref();
  ::mlir::Attribute shapeAttr();
  llvm::Optional<llvm::ArrayRef<int64_t>> shape();
  ::mlir::StringAttr containerAttr();
  ::llvm::StringRef container();
  ::mlir::StringAttr shared_nameAttr();
  ::llvm::StringRef shared_name();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void shapeAttr(::mlir::Attribute attr);
  void containerAttr(::mlir::StringAttr attr);
  void shared_nameAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type ref, ::mlir::Attribute shape, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute shape, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type ref, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::VariableOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VariableShapeOp declarations
//===----------------------------------------------------------------------===//

class VariableShapeOpAdaptor {
public:
  VariableShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  VariableShapeOpAdaptor(VariableShapeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class VariableShapeOp : public ::mlir::Op<VariableShapeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = VariableShapeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("out_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier out_typeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier out_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.VariableShape");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type out_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::OpFoldResult fold(::llvm::ArrayRef<::mlir::Attribute> operands);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::VariableShapeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VariableV2Op declarations
//===----------------------------------------------------------------------===//

class VariableV2OpAdaptor {
public:
  VariableV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  VariableV2OpAdaptor(VariableV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute shape();
  ::mlir::StringAttr container();
  ::mlir::StringAttr shared_name();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class VariableV2Op : public ::mlir::Op<VariableV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = VariableV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape"), ::llvm::StringRef("container"), ::llvm::StringRef("shared_name"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier containerAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier containerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier shared_nameAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier shared_nameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.VariableV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value ref();
  ::mlir::Attribute shapeAttr();
  llvm::Optional<llvm::ArrayRef<int64_t>> shape();
  ::mlir::StringAttr containerAttr();
  ::llvm::StringRef container();
  ::mlir::StringAttr shared_nameAttr();
  ::llvm::StringRef shared_name();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void shapeAttr(::mlir::Attribute attr);
  void containerAttr(::mlir::StringAttr attr);
  void shared_nameAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type ref, ::mlir::Attribute shape, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute shape, ::mlir::StringAttr container, ::mlir::StringAttr shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type ref, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef container, ::llvm::StringRef shared_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::VariableV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WhereOp declarations
//===----------------------------------------------------------------------===//

class WhereOpAdaptor {
public:
  WhereOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WhereOpAdaptor(WhereOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WhereOp : public ::mlir::Op<WhereOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WhereOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Where");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value index();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type index, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WhereOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WhileOp declarations
//===----------------------------------------------------------------------===//

class WhileOpAdaptor {
public:
  WhileOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WhileOpAdaptor(WhileOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::FlatSymbolRefAttr cond();
  ::mlir::FlatSymbolRefAttr body();
  ::mlir::IntegerAttr parallel_iterations();
  ::mlir::BoolAttr is_stateless();
  ::mlir::UnitAttr shape_invariant();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WhileOp : public ::mlir::Op<WhileOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::SymbolUserOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WhileOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("cond"), ::llvm::StringRef("body"), ::llvm::StringRef("parallel_iterations"), ::llvm::StringRef("is_stateless"), ::llvm::StringRef("shape_invariant"), ::llvm::StringRef("T"), ::llvm::StringRef("output_shapes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier condAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier condAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier bodyAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier bodyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier parallel_iterationsAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier parallel_iterationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier is_statelessAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier is_statelessAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier shape_invariantAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier shape_invariantAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier output_shapesAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier output_shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.While");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::FlatSymbolRefAttr condAttr();
  ::llvm::StringRef cond();
  ::mlir::FlatSymbolRefAttr bodyAttr();
  ::llvm::StringRef body();
  ::mlir::IntegerAttr parallel_iterationsAttr();
  uint64_t parallel_iterations();
  ::mlir::BoolAttr is_statelessAttr();
  bool is_stateless();
  ::mlir::UnitAttr shape_invariantAttr();
  bool shape_invariant();
  mlir::OperandElementTypeRange T();
  mlir::TF::ResultShapeRange output_shapes();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void condAttr(::mlir::FlatSymbolRefAttr attr);
  void bodyAttr(::mlir::FlatSymbolRefAttr attr);
  void parallel_iterationsAttr(::mlir::IntegerAttr attr);
  void is_statelessAttr(::mlir::BoolAttr attr);
  void shape_invariantAttr(::mlir::UnitAttr attr);
  ::mlir::Attribute removeShape_invariantAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::mlir::FlatSymbolRefAttr cond, ::mlir::FlatSymbolRefAttr body, ::mlir::IntegerAttr parallel_iterations, ::mlir::BoolAttr is_stateless, /*optional*/::mlir::UnitAttr shape_invariant);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::llvm::StringRef cond, ::llvm::StringRef body, uint64_t parallel_iterations, bool is_stateless, /*optional*/bool shape_invariant);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  ::mlir::LogicalResult verifySymbolUses(::mlir::SymbolTableCollection &symbolTable);

    // Get the condition function.
    FuncOp cond_function() {
      return SymbolTable::lookupNearestSymbolFrom<FuncOp>(*this, condAttr());
    }

    // Get the body function.
    FuncOp body_function() {
      return SymbolTable::lookupNearestSymbolFrom<FuncOp>(*this, bodyAttr());
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 7 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WhileOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WhileRegionOp declarations
//===----------------------------------------------------------------------===//

class WhileRegionOpAdaptor {
public:
  WhileRegionOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WhileRegionOpAdaptor(WhileRegionOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr parallel_iterations();
  ::mlir::BoolAttr is_stateless();
  ::mlir::UnitAttr shape_invariant();
  ::mlir::RegionRange getRegions();
  ::mlir::Region &cond();
  ::mlir::Region &body();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WhileRegionOp : public ::mlir::Op<WhileRegionOp, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::LoopLikeOpInterface::Trait, ::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WhileRegionOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("parallel_iterations"), ::llvm::StringRef("is_stateless"), ::llvm::StringRef("shape_invariant")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier parallel_iterationsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier parallel_iterationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier is_statelessAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier is_statelessAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier shape_invariantAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier shape_invariantAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WhileRegion");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::Region &cond();
  ::mlir::Region &body();
  ::mlir::IntegerAttr parallel_iterationsAttr();
  uint64_t parallel_iterations();
  ::mlir::BoolAttr is_statelessAttr();
  bool is_stateless();
  ::mlir::UnitAttr shape_invariantAttr();
  bool shape_invariant();
  void parallel_iterationsAttr(::mlir::IntegerAttr attr);
  void is_statelessAttr(::mlir::BoolAttr attr);
  void shape_invariantAttr(::mlir::UnitAttr attr);
  ::mlir::Attribute removeShape_invariantAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::mlir::IntegerAttr parallel_iterations, ::mlir::BoolAttr is_stateless, /*optional*/::mlir::UnitAttr shape_invariant);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, uint64_t parallel_iterations, bool is_stateless, /*optional*/bool shape_invariant);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  bool isDefinedOutsideOfLoop(::mlir::Value  value);
  ::mlir::Region &getLoopBody();
  ::mlir::LogicalResult moveOutOfLoop(::mlir::ArrayRef<::mlir::Operation *> ops);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WhileRegionOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteAudioSummaryOp declarations
//===----------------------------------------------------------------------===//

class WriteAudioSummaryOpAdaptor {
public:
  WriteAudioSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WriteAudioSummaryOpAdaptor(WriteAudioSummaryOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value tensor();
  ::mlir::Value sample_rate();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr max_outputs();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WriteAudioSummaryOp : public ::mlir::Op<WriteAudioSummaryOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WriteAudioSummaryOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("max_outputs")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier max_outputsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier max_outputsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WriteAudioSummary");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value tensor();
  ::mlir::Value sample_rate();
  ::mlir::MutableOperandRange writerMutable();
  ::mlir::MutableOperandRange stepMutable();
  ::mlir::MutableOperandRange tagMutable();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange sample_rateMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::IntegerAttr max_outputsAttr();
  uint64_t max_outputs();
  void max_outputsAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, ::mlir::IntegerAttr max_outputs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, ::mlir::IntegerAttr max_outputs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, uint64_t max_outputs = 3);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, uint64_t max_outputs = 3);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WriteAudioSummaryOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteGraphSummaryOp declarations
//===----------------------------------------------------------------------===//

class WriteGraphSummaryOpAdaptor {
public:
  WriteGraphSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WriteGraphSummaryOpAdaptor(WriteGraphSummaryOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tensor();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WriteGraphSummaryOp : public ::mlir::Op<WriteGraphSummaryOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WriteGraphSummaryOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WriteGraphSummary");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tensor();
  ::mlir::MutableOperandRange writerMutable();
  ::mlir::MutableOperandRange stepMutable();
  ::mlir::MutableOperandRange tensorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WriteGraphSummaryOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteHistogramSummaryOp declarations
//===----------------------------------------------------------------------===//

class WriteHistogramSummaryOpAdaptor {
public:
  WriteHistogramSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WriteHistogramSummaryOpAdaptor(WriteHistogramSummaryOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value values();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WriteHistogramSummaryOp : public ::mlir::Op<WriteHistogramSummaryOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WriteHistogramSummaryOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WriteHistogramSummary");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value values();
  ::mlir::MutableOperandRange writerMutable();
  ::mlir::MutableOperandRange stepMutable();
  ::mlir::MutableOperandRange tagMutable();
  ::mlir::MutableOperandRange valuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value values);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value values);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WriteHistogramSummaryOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteImageSummaryOp declarations
//===----------------------------------------------------------------------===//

class WriteImageSummaryOpAdaptor {
public:
  WriteImageSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WriteImageSummaryOpAdaptor(WriteImageSummaryOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value tensor();
  ::mlir::Value bad_color();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr max_images();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WriteImageSummaryOp : public ::mlir::Op<WriteImageSummaryOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WriteImageSummaryOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("max_images"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier max_imagesAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier max_imagesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WriteImageSummary");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value tensor();
  ::mlir::Value bad_color();
  ::mlir::MutableOperandRange writerMutable();
  ::mlir::MutableOperandRange stepMutable();
  ::mlir::MutableOperandRange tagMutable();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange bad_colorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::IntegerAttr max_imagesAttr();
  uint64_t max_images();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void max_imagesAttr(::mlir::IntegerAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, ::mlir::IntegerAttr max_images);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, ::mlir::IntegerAttr max_images);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, uint64_t max_images = 3);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, uint64_t max_images = 3);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WriteImageSummaryOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteRawProtoSummaryOp declarations
//===----------------------------------------------------------------------===//

class WriteRawProtoSummaryOpAdaptor {
public:
  WriteRawProtoSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WriteRawProtoSummaryOpAdaptor(WriteRawProtoSummaryOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tensor();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WriteRawProtoSummaryOp : public ::mlir::Op<WriteRawProtoSummaryOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WriteRawProtoSummaryOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WriteRawProtoSummary");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tensor();
  ::mlir::MutableOperandRange writerMutable();
  ::mlir::MutableOperandRange stepMutable();
  ::mlir::MutableOperandRange tensorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WriteRawProtoSummaryOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteScalarSummaryOp declarations
//===----------------------------------------------------------------------===//

class WriteScalarSummaryOpAdaptor {
public:
  WriteScalarSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WriteScalarSummaryOpAdaptor(WriteScalarSummaryOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WriteScalarSummaryOp : public ::mlir::Op<WriteScalarSummaryOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WriteScalarSummaryOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WriteScalarSummary");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tag();
  ::mlir::Value value();
  ::mlir::MutableOperandRange writerMutable();
  ::mlir::MutableOperandRange stepMutable();
  ::mlir::MutableOperandRange tagMutable();
  ::mlir::MutableOperandRange valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value value);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value value);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WriteScalarSummaryOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteSummaryOp declarations
//===----------------------------------------------------------------------===//

class WriteSummaryOpAdaptor {
public:
  WriteSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  WriteSummaryOpAdaptor(WriteSummaryOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tensor();
  ::mlir::Value tag();
  ::mlir::Value summary_metadata();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class WriteSummaryOp : public ::mlir::Op<WriteSummaryOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::DerivedAttributeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WriteSummaryOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.WriteSummary");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value writer();
  ::mlir::Value step();
  ::mlir::Value tensor();
  ::mlir::Value tag();
  ::mlir::Value summary_metadata();
  ::mlir::MutableOperandRange writerMutable();
  ::mlir::MutableOperandRange stepMutable();
  ::mlir::MutableOperandRange tensorMutable();
  ::mlir::MutableOperandRange tagMutable();
  ::mlir::MutableOperandRange summary_metadataMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor, ::mlir::Value tag, ::mlir::Value summary_metadata);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor, ::mlir::Value tag, ::mlir::Value summary_metadata);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::WriteSummaryOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XdivyOp declarations
//===----------------------------------------------------------------------===//

class XdivyOpAdaptor {
public:
  XdivyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XdivyOpAdaptor(XdivyOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XdivyOp : public ::mlir::Op<XdivyOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::OpTrait::TF::SameOperandsAndResultElementTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XdivyOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Xdivy");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XdivyOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaAllReduceOp declarations
//===----------------------------------------------------------------------===//

class XlaAllReduceOpAdaptor {
public:
  XlaAllReduceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaAllReduceOpAdaptor(XlaAllReduceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value group_assignment();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr reduce_op();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaAllReduceOp : public ::mlir::Op<XlaAllReduceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaAllReduceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("reduce_op"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier reduce_opAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier reduce_opAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaAllReduce");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value group_assignment();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange group_assignmentMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr reduce_opAttr();
  ::llvm::StringRef reduce_op();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void reduce_opAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::StringAttr reduce_op);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::StringAttr reduce_op);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value group_assignment, ::llvm::StringRef reduce_op);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_assignment, ::llvm::StringRef reduce_op);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaAllReduceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaBroadcastHelperOp declarations
//===----------------------------------------------------------------------===//

class XlaBroadcastHelperOpAdaptor {
public:
  XlaBroadcastHelperOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaBroadcastHelperOpAdaptor(XlaBroadcastHelperOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::Value broadcast_dims();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaBroadcastHelperOp : public ::mlir::Op<XlaBroadcastHelperOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::InferTypeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaBroadcastHelperOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaBroadcastHelper");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::Value broadcast_dims();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  ::mlir::MutableOperandRange broadcast_dimsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value lhs_output();
  ::mlir::Value rhs_output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type lhs_output, ::mlir::Type rhs_output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value broadcast_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value broadcast_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value broadcast_dims);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static ::mlir::LogicalResult inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // InferTypeOpInterface:
    static bool isCompatibleReturnTypes(TypeRange l, TypeRange r) {
      return ArraysAreCastCompatible(l, r);
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaBroadcastHelperOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaClusterOutputOp declarations
//===----------------------------------------------------------------------===//

class XlaClusterOutputOpAdaptor {
public:
  XlaClusterOutputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaClusterOutputOpAdaptor(XlaClusterOutputOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaClusterOutputOp : public ::mlir::Op<XlaClusterOutputOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaClusterOutputOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaClusterOutput");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value outputs();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type outputs, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaClusterOutputOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaConvOp declarations
//===----------------------------------------------------------------------===//

class XlaConvOpAdaptor {
public:
  XlaConvOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaConvOpAdaptor(XlaConvOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::Value window_strides();
  ::mlir::Value padding();
  ::mlir::Value lhs_dilation();
  ::mlir::Value rhs_dilation();
  ::mlir::Value feature_group_count();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr dimension_numbers();
  ::mlir::StringAttr precision_config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaConvOp : public ::mlir::Op<XlaConvOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<7>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaConvOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension_numbers"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimension_numbersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimension_numbersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier precision_configAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier precision_configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaConv");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::Value window_strides();
  ::mlir::Value padding();
  ::mlir::Value lhs_dilation();
  ::mlir::Value rhs_dilation();
  ::mlir::Value feature_group_count();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  ::mlir::MutableOperandRange window_stridesMutable();
  ::mlir::MutableOperandRange paddingMutable();
  ::mlir::MutableOperandRange lhs_dilationMutable();
  ::mlir::MutableOperandRange rhs_dilationMutable();
  ::mlir::MutableOperandRange feature_group_countMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr dimension_numbersAttr();
  ::llvm::StringRef dimension_numbers();
  ::mlir::StringAttr precision_configAttr();
  ::llvm::StringRef precision_config();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimension_numbersAttr(::mlir::StringAttr attr);
  void precision_configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaConvOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaConvV2Op declarations
//===----------------------------------------------------------------------===//

class XlaConvV2OpAdaptor {
public:
  XlaConvV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaConvV2OpAdaptor(XlaConvV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::Value window_strides();
  ::mlir::Value padding();
  ::mlir::Value lhs_dilation();
  ::mlir::Value rhs_dilation();
  ::mlir::Value feature_group_count();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr dimension_numbers();
  ::mlir::StringAttr precision_config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaConvV2Op : public ::mlir::Op<XlaConvV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<7>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaConvV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension_numbers"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("LhsT"), ::llvm::StringRef("RhsT"), ::llvm::StringRef("Tindices"), ::llvm::StringRef("preferred_element_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimension_numbersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimension_numbersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier precision_configAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier precision_configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier LhsTAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier LhsTAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier RhsTAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier RhsTAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier preferred_element_typeAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier preferred_element_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaConvV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::Value window_strides();
  ::mlir::Value padding();
  ::mlir::Value lhs_dilation();
  ::mlir::Value rhs_dilation();
  ::mlir::Value feature_group_count();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  ::mlir::MutableOperandRange window_stridesMutable();
  ::mlir::MutableOperandRange paddingMutable();
  ::mlir::MutableOperandRange lhs_dilationMutable();
  ::mlir::MutableOperandRange rhs_dilationMutable();
  ::mlir::MutableOperandRange feature_group_countMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr dimension_numbersAttr();
  ::llvm::StringRef dimension_numbers();
  ::mlir::StringAttr precision_configAttr();
  ::llvm::StringRef precision_config();
  ::mlir::Type LhsT();
  ::mlir::Type RhsT();
  ::mlir::Type Tindices();
  ::mlir::Type preferred_element_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimension_numbersAttr(::mlir::StringAttr attr);
  void precision_configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 6 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaConvV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaDotOp declarations
//===----------------------------------------------------------------------===//

class XlaDotOpAdaptor {
public:
  XlaDotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaDotOpAdaptor(XlaDotOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr dimension_numbers();
  ::mlir::StringAttr precision_config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaDotOp : public ::mlir::Op<XlaDotOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaDotOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension_numbers"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimension_numbersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimension_numbersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier precision_configAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier precision_configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaDot");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr dimension_numbersAttr();
  ::llvm::StringRef dimension_numbers();
  ::mlir::StringAttr precision_configAttr();
  ::llvm::StringRef precision_config();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimension_numbersAttr(::mlir::StringAttr attr);
  void precision_configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaDotOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaDotV2Op declarations
//===----------------------------------------------------------------------===//

class XlaDotV2OpAdaptor {
public:
  XlaDotV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaDotV2OpAdaptor(XlaDotV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr dimension_numbers();
  ::mlir::StringAttr precision_config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaDotV2Op : public ::mlir::Op<XlaDotV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaDotV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension_numbers"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("LhsT"), ::llvm::StringRef("RhsT"), ::llvm::StringRef("preferred_element_type")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimension_numbersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimension_numbersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier precision_configAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier precision_configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier LhsTAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier LhsTAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier RhsTAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier RhsTAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier preferred_element_typeAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier preferred_element_typeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaDotV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value lhs();
  ::mlir::Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr dimension_numbersAttr();
  ::llvm::StringRef dimension_numbers();
  ::mlir::StringAttr precision_configAttr();
  ::llvm::StringRef precision_config();
  ::mlir::Type LhsT();
  ::mlir::Type RhsT();
  ::mlir::Type preferred_element_type();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimension_numbersAttr(::mlir::StringAttr attr);
  void precision_configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaDotV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaDynamicSliceOp declarations
//===----------------------------------------------------------------------===//

class XlaDynamicSliceOpAdaptor {
public:
  XlaDynamicSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaDynamicSliceOpAdaptor(XlaDynamicSliceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value start_indices();
  ::mlir::Value size_indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaDynamicSliceOp : public ::mlir::Op<XlaDynamicSliceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaDynamicSliceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaDynamicSlice");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value start_indices();
  ::mlir::Value size_indices();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange start_indicesMutable();
  ::mlir::MutableOperandRange size_indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value start_indices, ::mlir::Value size_indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value start_indices, ::mlir::Value size_indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaDynamicSliceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaDynamicUpdateSliceOp declarations
//===----------------------------------------------------------------------===//

class XlaDynamicUpdateSliceOpAdaptor {
public:
  XlaDynamicUpdateSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaDynamicUpdateSliceOpAdaptor(XlaDynamicUpdateSliceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value update();
  ::mlir::Value indices();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaDynamicUpdateSliceOp : public ::mlir::Op<XlaDynamicUpdateSliceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaDynamicUpdateSliceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaDynamicUpdateSlice");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value update();
  ::mlir::Value indices();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange updateMutable();
  ::mlir::MutableOperandRange indicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value update, ::mlir::Value indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value update, ::mlir::Value indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaDynamicUpdateSliceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaEinsumOp declarations
//===----------------------------------------------------------------------===//

class XlaEinsumOpAdaptor {
public:
  XlaEinsumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaEinsumOpAdaptor(XlaEinsumOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value b();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr equation();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaEinsumOp : public ::mlir::Op<XlaEinsumOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaEinsumOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("equation"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier equationAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier equationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaEinsum");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::Value b();
  ::mlir::MutableOperandRange aMutable();
  ::mlir::MutableOperandRange bMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value product();
  ::mlir::StringAttr equationAttr();
  ::llvm::StringRef equation();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void equationAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::mlir::StringAttr equation);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::StringAttr equation);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::llvm::StringRef equation);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::llvm::StringRef equation);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaEinsumOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaGatherOp declarations
//===----------------------------------------------------------------------===//

class XlaGatherOpAdaptor {
public:
  XlaGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaGatherOpAdaptor(XlaGatherOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value operand();
  ::mlir::Value start_indices();
  ::mlir::Value slice_sizes();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr dimension_numbers();
  ::mlir::BoolAttr indices_are_sorted();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaGatherOp : public ::mlir::Op<XlaGatherOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaGatherOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension_numbers"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimension_numbersAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimension_numbersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier indices_are_sortedAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier indices_are_sortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaGather");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value operand();
  ::mlir::Value start_indices();
  ::mlir::Value slice_sizes();
  ::mlir::MutableOperandRange operandMutable();
  ::mlir::MutableOperandRange start_indicesMutable();
  ::mlir::MutableOperandRange slice_sizesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr dimension_numbersAttr();
  ::llvm::StringRef dimension_numbers();
  ::mlir::BoolAttr indices_are_sortedAttr();
  bool indices_are_sorted();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimension_numbersAttr(::mlir::StringAttr attr);
  void indices_are_sortedAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::llvm::StringRef dimension_numbers, bool indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::llvm::StringRef dimension_numbers, bool indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaGatherOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaHostComputeOp declarations
//===----------------------------------------------------------------------===//

class XlaHostComputeOpAdaptor {
public:
  XlaHostComputeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaHostComputeOpAdaptor(XlaHostComputeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr ancestors();
  ::mlir::ArrayAttr shapes();
  ::mlir::SymbolRefAttr shape_inference_graph();
  ::mlir::StringAttr key();
  ::mlir::StringAttr send_key();
  ::mlir::StringAttr recv_key();
  ::mlir::IntegerAttr cost_estimate_ns();
  ::mlir::IntegerAttr tpu_core();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaHostComputeOp : public ::mlir::Op<XlaHostComputeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaHostComputeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("ancestors"), ::llvm::StringRef("shapes"), ::llvm::StringRef("shape_inference_graph"), ::llvm::StringRef("key"), ::llvm::StringRef("send_key"), ::llvm::StringRef("recv_key"), ::llvm::StringRef("cost_estimate_ns"), ::llvm::StringRef("tpu_core"), ::llvm::StringRef("Tinputs"), ::llvm::StringRef("Toutputs")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier ancestorsAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier ancestorsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier shapesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier shapesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier shape_inference_graphAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier shape_inference_graphAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier keyAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier keyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier send_keyAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier send_keyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  ::mlir::Identifier recv_keyAttrName() {
    return getAttributeNameForIndex(5);
  }
  static ::mlir::Identifier recv_keyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }
  ::mlir::Identifier cost_estimate_nsAttrName() {
    return getAttributeNameForIndex(6);
  }
  static ::mlir::Identifier cost_estimate_nsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }
  ::mlir::Identifier tpu_coreAttrName() {
    return getAttributeNameForIndex(7);
  }
  static ::mlir::Identifier tpu_coreAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }
  ::mlir::Identifier TinputsAttrName() {
    return getAttributeNameForIndex(8);
  }
  static ::mlir::Identifier TinputsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }
  ::mlir::Identifier ToutputsAttrName() {
    return getAttributeNameForIndex(9);
  }
  static ::mlir::Identifier ToutputsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaHostCompute");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::MutableOperandRange inputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range outputs();
  ::mlir::ArrayAttr ancestorsAttr();
  ::mlir::ArrayAttr ancestors();
  ::mlir::ArrayAttr shapesAttr();
  ::mlir::ArrayAttr shapes();
  ::mlir::SymbolRefAttr shape_inference_graphAttr();
  ::llvm::Optional< ::mlir::SymbolRefAttr > shape_inference_graph();
  ::mlir::StringAttr keyAttr();
  ::llvm::StringRef key();
  ::mlir::StringAttr send_keyAttr();
  ::llvm::StringRef send_key();
  ::mlir::StringAttr recv_keyAttr();
  ::llvm::StringRef recv_key();
  ::mlir::IntegerAttr cost_estimate_nsAttr();
  uint64_t cost_estimate_ns();
  ::mlir::IntegerAttr tpu_coreAttr();
  uint64_t tpu_core();
  mlir::OperandElementTypeRange Tinputs();
  mlir::ResultElementTypeRange Toutputs();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void ancestorsAttr(::mlir::ArrayAttr attr);
  void shapesAttr(::mlir::ArrayAttr attr);
  void shape_inference_graphAttr(::mlir::SymbolRefAttr attr);
  void keyAttr(::mlir::StringAttr attr);
  void send_keyAttr(::mlir::StringAttr attr);
  void recv_keyAttr(::mlir::StringAttr attr);
  void cost_estimate_nsAttr(::mlir::IntegerAttr attr);
  void tpu_coreAttr(::mlir::IntegerAttr attr);
  ::mlir::Attribute removeShape_inference_graphAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::ArrayAttr ancestors, ::mlir::ArrayAttr shapes, /*optional*/::mlir::SymbolRefAttr shape_inference_graph, ::mlir::StringAttr key, ::mlir::StringAttr send_key, ::mlir::StringAttr recv_key, ::mlir::IntegerAttr cost_estimate_ns, ::mlir::IntegerAttr tpu_core);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::ArrayAttr ancestors, ::mlir::ArrayAttr shapes, /*optional*/::mlir::SymbolRefAttr shape_inference_graph, ::llvm::StringRef key, ::llvm::StringRef send_key, ::llvm::StringRef recv_key, uint64_t cost_estimate_ns = 1000000, uint64_t tpu_core = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 10 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaHostComputeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaKeyValueSortOp declarations
//===----------------------------------------------------------------------===//

class XlaKeyValueSortOpAdaptor {
public:
  XlaKeyValueSortOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaKeyValueSortOpAdaptor(XlaKeyValueSortOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value keys();
  ::mlir::Value values();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaKeyValueSortOp : public ::mlir::Op<XlaKeyValueSortOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaKeyValueSortOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("K"), ::llvm::StringRef("V")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier KAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier KAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier VAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier VAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaKeyValueSort");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value keys();
  ::mlir::Value values();
  ::mlir::MutableOperandRange keysMutable();
  ::mlir::MutableOperandRange valuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value sorted_keys();
  ::mlir::Value sorted_values();
  ::mlir::Type K();
  ::mlir::Type V();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type sorted_keys, ::mlir::Type sorted_values, ::mlir::Value keys, ::mlir::Value values);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value keys, ::mlir::Value values);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaKeyValueSortOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaPadOp declarations
//===----------------------------------------------------------------------===//

class XlaPadOpAdaptor {
public:
  XlaPadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaPadOpAdaptor(XlaPadOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value padding_value();
  ::mlir::Value padding_low();
  ::mlir::Value padding_high();
  ::mlir::Value padding_interior();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaPadOp : public ::mlir::Op<XlaPadOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaPadOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaPad");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value padding_value();
  ::mlir::Value padding_low();
  ::mlir::Value padding_high();
  ::mlir::Value padding_interior();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange padding_valueMutable();
  ::mlir::MutableOperandRange padding_lowMutable();
  ::mlir::MutableOperandRange padding_highMutable();
  ::mlir::MutableOperandRange padding_interiorMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value padding_value, ::mlir::Value padding_low, ::mlir::Value padding_high, ::mlir::Value padding_interior);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value padding_value, ::mlir::Value padding_low, ::mlir::Value padding_high, ::mlir::Value padding_interior);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaPadOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaRecvFromHostOp declarations
//===----------------------------------------------------------------------===//

class XlaRecvFromHostOpAdaptor {
public:
  XlaRecvFromHostOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaRecvFromHostOpAdaptor(XlaRecvFromHostOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute shape();
  ::mlir::StringAttr key();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaRecvFromHostOp : public ::mlir::Op<XlaRecvFromHostOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaRecvFromHostOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("shape"), ::llvm::StringRef("key"), ::llvm::StringRef("Toutput")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier keyAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier keyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier ToutputAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier ToutputAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaRecvFromHost");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Attribute shapeAttr();
  llvm::Optional<llvm::ArrayRef<int64_t>> shape();
  ::mlir::StringAttr keyAttr();
  ::llvm::StringRef key();
  ::mlir::Type Toutput();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void shapeAttr(::mlir::Attribute attr);
  void keyAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Attribute shape, ::mlir::StringAttr key);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute shape, ::mlir::StringAttr key);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef key);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef key);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaRecvFromHostOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaReduceOp declarations
//===----------------------------------------------------------------------===//

class XlaReduceOpAdaptor {
public:
  XlaReduceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaReduceOpAdaptor(XlaReduceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value init_value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr dimensions_to_reduce();
  ::mlir::SymbolRefAttr reducer();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaReduceOp : public ::mlir::Op<XlaReduceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaReduceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions_to_reduce"), ::llvm::StringRef("reducer"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimensions_to_reduceAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimensions_to_reduceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier reducerAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier reducerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaReduce");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value init_value();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange init_valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::ArrayAttr dimensions_to_reduceAttr();
  ::mlir::ArrayAttr dimensions_to_reduce();
  ::mlir::SymbolRefAttr reducerAttr();
  ::mlir::SymbolRefAttr reducer();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimensions_to_reduceAttr(::mlir::ArrayAttr attr);
  void reducerAttr(::mlir::SymbolRefAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value init_value, ::mlir::ArrayAttr dimensions_to_reduce, ::mlir::SymbolRefAttr reducer);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value init_value, ::mlir::ArrayAttr dimensions_to_reduce, ::mlir::SymbolRefAttr reducer);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaReduceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaReduceScatterOp declarations
//===----------------------------------------------------------------------===//

class XlaReduceScatterOpAdaptor {
public:
  XlaReduceScatterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaReduceScatterOpAdaptor(XlaReduceScatterOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value group_assignment();
  ::mlir::Value scatter_dimension();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr reduce_op();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaReduceScatterOp : public ::mlir::Op<XlaReduceScatterOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaReduceScatterOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("reduce_op"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier reduce_opAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier reduce_opAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaReduceScatter");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value group_assignment();
  ::mlir::Value scatter_dimension();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange group_assignmentMutable();
  ::mlir::MutableOperandRange scatter_dimensionMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr reduce_opAttr();
  ::llvm::StringRef reduce_op();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void reduce_opAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::Value scatter_dimension, ::mlir::StringAttr reduce_op);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::Value scatter_dimension, ::mlir::StringAttr reduce_op);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::Value scatter_dimension, ::llvm::StringRef reduce_op);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::Value scatter_dimension, ::llvm::StringRef reduce_op);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaReduceScatterOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaReduceWindowOp declarations
//===----------------------------------------------------------------------===//

class XlaReduceWindowOpAdaptor {
public:
  XlaReduceWindowOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaReduceWindowOpAdaptor(XlaReduceWindowOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value init_value();
  ::mlir::Value window_dimensions();
  ::mlir::Value window_strides();
  ::mlir::Value base_dilations();
  ::mlir::Value window_dilations();
  ::mlir::Value padding();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr computation();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaReduceWindowOp : public ::mlir::Op<XlaReduceWindowOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<7>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaReduceWindowOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("computation"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier computationAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier computationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaReduceWindow");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value init_value();
  ::mlir::Value window_dimensions();
  ::mlir::Value window_strides();
  ::mlir::Value base_dilations();
  ::mlir::Value window_dilations();
  ::mlir::Value padding();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange init_valueMutable();
  ::mlir::MutableOperandRange window_dimensionsMutable();
  ::mlir::MutableOperandRange window_stridesMutable();
  ::mlir::MutableOperandRange base_dilationsMutable();
  ::mlir::MutableOperandRange window_dilationsMutable();
  ::mlir::MutableOperandRange paddingMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::SymbolRefAttr computationAttr();
  ::mlir::SymbolRefAttr computation();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void computationAttr(::mlir::SymbolRefAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value init_value, ::mlir::Value window_dimensions, ::mlir::Value window_strides, ::mlir::Value base_dilations, ::mlir::Value window_dilations, ::mlir::Value padding, ::mlir::SymbolRefAttr computation);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value init_value, ::mlir::Value window_dimensions, ::mlir::Value window_strides, ::mlir::Value base_dilations, ::mlir::Value window_dilations, ::mlir::Value padding, ::mlir::SymbolRefAttr computation);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaReduceWindowOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaRemoveDynamicDimensionSizeOp declarations
//===----------------------------------------------------------------------===//

class XlaRemoveDynamicDimensionSizeOpAdaptor {
public:
  XlaRemoveDynamicDimensionSizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaRemoveDynamicDimensionSizeOpAdaptor(XlaRemoveDynamicDimensionSizeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value dim_index();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaRemoveDynamicDimensionSizeOp : public ::mlir::Op<XlaRemoveDynamicDimensionSizeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaRemoveDynamicDimensionSizeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaRemoveDynamicDimensionSize");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value dim_index();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange dim_indexMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value dim_index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value dim_index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaRemoveDynamicDimensionSizeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaReplicaIdOp declarations
//===----------------------------------------------------------------------===//

class XlaReplicaIdOpAdaptor {
public:
  XlaReplicaIdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaReplicaIdOpAdaptor(XlaReplicaIdOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaReplicaIdOp : public ::mlir::Op<XlaReplicaIdOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::ZeroOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaReplicaIdOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaReplicaId");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value id();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaReplicaIdOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaRngBitGeneratorOp declarations
//===----------------------------------------------------------------------===//

class XlaRngBitGeneratorOpAdaptor {
public:
  XlaRngBitGeneratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaRngBitGeneratorOpAdaptor(XlaRngBitGeneratorOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value algorithm();
  ::mlir::Value initial_state();
  ::mlir::Value shape();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaRngBitGeneratorOp : public ::mlir::Op<XlaRngBitGeneratorOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaRngBitGeneratorOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("Tshape"), ::llvm::StringRef("dtype")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TshapeAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TshapeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dtypeAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dtypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaRngBitGenerator");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value algorithm();
  ::mlir::Value initial_state();
  ::mlir::Value shape();
  ::mlir::MutableOperandRange algorithmMutable();
  ::mlir::MutableOperandRange initial_stateMutable();
  ::mlir::MutableOperandRange shapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output_key();
  ::mlir::Value output();
  ::mlir::Type Tshape();
  ::mlir::Type dtype();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_key, ::mlir::Type output, ::mlir::Value algorithm, ::mlir::Value initial_state, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value algorithm, ::mlir::Value initial_state, ::mlir::Value shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaRngBitGeneratorOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaScatterOp declarations
//===----------------------------------------------------------------------===//

class XlaScatterOpAdaptor {
public:
  XlaScatterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaScatterOpAdaptor(XlaScatterOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value operand();
  ::mlir::Value scatter_indices();
  ::mlir::Value updates();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr update_computation();
  ::mlir::StringAttr dimension_numbers();
  ::mlir::BoolAttr indices_are_sorted();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaScatterOp : public ::mlir::Op<XlaScatterOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaScatterOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("update_computation"), ::llvm::StringRef("dimension_numbers"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier update_computationAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier update_computationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier dimension_numbersAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier dimension_numbersAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier indices_are_sortedAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier indices_are_sortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(4);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaScatter");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value operand();
  ::mlir::Value scatter_indices();
  ::mlir::Value updates();
  ::mlir::MutableOperandRange operandMutable();
  ::mlir::MutableOperandRange scatter_indicesMutable();
  ::mlir::MutableOperandRange updatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::SymbolRefAttr update_computationAttr();
  ::mlir::SymbolRefAttr update_computation();
  ::mlir::StringAttr dimension_numbersAttr();
  ::llvm::StringRef dimension_numbers();
  ::mlir::BoolAttr indices_are_sortedAttr();
  bool indices_are_sorted();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void update_computationAttr(::mlir::SymbolRefAttr attr);
  void dimension_numbersAttr(::mlir::StringAttr attr);
  void indices_are_sortedAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::llvm::StringRef dimension_numbers, bool indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::llvm::StringRef dimension_numbers, bool indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 5 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaScatterOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSelectAndScatterOp declarations
//===----------------------------------------------------------------------===//

class XlaSelectAndScatterOpAdaptor {
public:
  XlaSelectAndScatterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaSelectAndScatterOpAdaptor(XlaSelectAndScatterOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value operand();
  ::mlir::Value window_dimensions();
  ::mlir::Value window_strides();
  ::mlir::Value padding();
  ::mlir::Value source();
  ::mlir::Value init_value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr select();
  ::mlir::SymbolRefAttr scatter();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaSelectAndScatterOp : public ::mlir::Op<XlaSelectAndScatterOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<6>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaSelectAndScatterOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("select"), ::llvm::StringRef("scatter"), ::llvm::StringRef("T"), ::llvm::StringRef("Tindices")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier selectAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier selectAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier scatterAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier scatterAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TindicesAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TindicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaSelectAndScatter");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value operand();
  ::mlir::Value window_dimensions();
  ::mlir::Value window_strides();
  ::mlir::Value padding();
  ::mlir::Value source();
  ::mlir::Value init_value();
  ::mlir::MutableOperandRange operandMutable();
  ::mlir::MutableOperandRange window_dimensionsMutable();
  ::mlir::MutableOperandRange window_stridesMutable();
  ::mlir::MutableOperandRange paddingMutable();
  ::mlir::MutableOperandRange sourceMutable();
  ::mlir::MutableOperandRange init_valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::SymbolRefAttr selectAttr();
  ::mlir::SymbolRefAttr select();
  ::mlir::SymbolRefAttr scatterAttr();
  ::mlir::SymbolRefAttr scatter();
  ::mlir::Type T();
  ::mlir::Type Tindices();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void selectAttr(::mlir::SymbolRefAttr attr);
  void scatterAttr(::mlir::SymbolRefAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value window_dimensions, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value source, ::mlir::Value init_value, ::mlir::SymbolRefAttr select, ::mlir::SymbolRefAttr scatter);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value window_dimensions, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value source, ::mlir::Value init_value, ::mlir::SymbolRefAttr select, ::mlir::SymbolRefAttr scatter);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaSelectAndScatterOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSelfAdjointEigOp declarations
//===----------------------------------------------------------------------===//

class XlaSelfAdjointEigOpAdaptor {
public:
  XlaSelfAdjointEigOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaSelfAdjointEigOpAdaptor(XlaSelfAdjointEigOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr lower();
  ::mlir::IntegerAttr max_iter();
  ::mlir::FloatAttr epsilon();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaSelfAdjointEigOp : public ::mlir::Op<XlaSelfAdjointEigOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaSelfAdjointEigOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("lower"), ::llvm::StringRef("max_iter"), ::llvm::StringRef("epsilon"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier lowerAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier lowerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier max_iterAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier max_iterAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier epsilonAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier epsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaSelfAdjointEig");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::MutableOperandRange aMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value w();
  ::mlir::Value v();
  ::mlir::BoolAttr lowerAttr();
  bool lower();
  ::mlir::IntegerAttr max_iterAttr();
  uint64_t max_iter();
  ::mlir::FloatAttr epsilonAttr();
  ::llvm::APFloat epsilon();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void lowerAttr(::mlir::BoolAttr attr);
  void max_iterAttr(::mlir::IntegerAttr attr);
  void epsilonAttr(::mlir::FloatAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type w, ::mlir::Type v, ::mlir::Value a, ::mlir::BoolAttr lower, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::BoolAttr lower, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type w, ::mlir::Type v, ::mlir::Value a, bool lower, uint64_t max_iter, ::llvm::APFloat epsilon);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, bool lower, uint64_t max_iter, ::llvm::APFloat epsilon);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaSelfAdjointEigOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSendToHostOp declarations
//===----------------------------------------------------------------------===//

class XlaSendToHostOpAdaptor {
public:
  XlaSendToHostOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaSendToHostOpAdaptor(XlaSendToHostOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr key();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaSendToHostOp : public ::mlir::Op<XlaSendToHostOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaSendToHostOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("key"), ::llvm::StringRef("Tinput")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier keyAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier keyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier TinputAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier TinputAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaSendToHost");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::StringAttr keyAttr();
  ::llvm::StringRef key();
  ::mlir::Type Tinput();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void keyAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::StringAttr key);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr key);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::llvm::StringRef key);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef key);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 2 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaSendToHostOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSetDynamicDimensionSizeOp declarations
//===----------------------------------------------------------------------===//

class XlaSetDynamicDimensionSizeOpAdaptor {
public:
  XlaSetDynamicDimensionSizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaSetDynamicDimensionSizeOpAdaptor(XlaSetDynamicDimensionSizeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value dim_index();
  ::mlir::Value size();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaSetDynamicDimensionSizeOp : public ::mlir::Op<XlaSetDynamicDimensionSizeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::InferTypeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaSetDynamicDimensionSizeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaSetDynamicDimensionSize");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::Value dim_index();
  ::mlir::Value size();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange dim_indexMutable();
  ::mlir::MutableOperandRange sizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value dim_index, ::mlir::Value size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::Value dim_index, ::mlir::Value size);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value dim_index, ::mlir::Value size);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  static ::mlir::LogicalResult inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes);
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

    // InferTypeOpInterface:
    static bool isCompatibleReturnTypes(TypeRange l, TypeRange r) {
      return ArraysAreCastCompatible(l, r);
    }
  

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaSetDynamicDimensionSizeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaShardingOp declarations
//===----------------------------------------------------------------------===//

class XlaShardingOpAdaptor {
public:
  XlaShardingOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaShardingOpAdaptor(XlaShardingOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr sharding();
  ::mlir::StringAttr _XlaSharding();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaShardingOp : public ::mlir::Op<XlaShardingOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::NoConstantFold, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaShardingOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("sharding"), ::llvm::StringRef("_XlaSharding"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier shardingAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier shardingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier _XlaShardingAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier _XlaShardingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaSharding");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::StringAttr shardingAttr();
  ::llvm::StringRef sharding();
  ::mlir::StringAttr _XlaShardingAttr();
  ::llvm::Optional< ::llvm::StringRef > _XlaSharding();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void shardingAttr(::mlir::StringAttr attr);
  void _XlaShardingAttr(::mlir::StringAttr attr);
  ::mlir::Attribute remove_XlaShardingAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::StringAttr sharding, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr sharding, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::llvm::StringRef sharding, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef sharding, /*optional*/::mlir::StringAttr _XlaSharding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaShardingOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSortOp declarations
//===----------------------------------------------------------------------===//

class XlaSortOpAdaptor {
public:
  XlaSortOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaSortOpAdaptor(XlaSortOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaSortOp : public ::mlir::Op<XlaSortOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaSortOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaSort");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value input();
  ::mlir::MutableOperandRange inputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value output();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaSortOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSvdOp declarations
//===----------------------------------------------------------------------===//

class XlaSvdOpAdaptor {
public:
  XlaSvdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaSvdOpAdaptor(XlaSvdOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::IntegerAttr max_iter();
  ::mlir::FloatAttr epsilon();
  ::mlir::StringAttr precision_config();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaSvdOp : public ::mlir::Op<XlaSvdOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaSvdOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("max_iter"), ::llvm::StringRef("epsilon"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier max_iterAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier max_iterAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier epsilonAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier epsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier precision_configAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier precision_configAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaSvd");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value a();
  ::mlir::MutableOperandRange aMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value s();
  ::mlir::Value u();
  ::mlir::Value v();
  ::mlir::IntegerAttr max_iterAttr();
  uint64_t max_iter();
  ::mlir::FloatAttr epsilonAttr();
  ::llvm::APFloat epsilon();
  ::mlir::StringAttr precision_configAttr();
  ::llvm::StringRef precision_config();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void max_iterAttr(::mlir::IntegerAttr attr);
  void epsilonAttr(::mlir::FloatAttr attr);
  void precision_configAttr(::mlir::StringAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type s, ::mlir::Type u, ::mlir::Type v, ::mlir::Value a, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon, ::mlir::StringAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type s, ::mlir::Type u, ::mlir::Type v, ::mlir::Value a, uint64_t max_iter, ::llvm::APFloat epsilon, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, uint64_t max_iter, ::llvm::APFloat epsilon, ::llvm::StringRef precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaSvdOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaVariadicReduceOp declarations
//===----------------------------------------------------------------------===//

class XlaVariadicReduceOpAdaptor {
public:
  XlaVariadicReduceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaVariadicReduceOpAdaptor(XlaVariadicReduceOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange input();
  ::mlir::ValueRange init_value();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr dimensions_to_reduce();
  ::mlir::SymbolRefAttr reducer();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaVariadicReduceOp : public ::mlir::Op<XlaVariadicReduceOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaVariadicReduceOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions_to_reduce"), ::llvm::StringRef("reducer"), ::llvm::StringRef("N"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimensions_to_reduceAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimensions_to_reduceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier reducerAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier reducerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier NAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier NAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaVariadicReduce");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range input();
  ::mlir::Operation::operand_range init_value();
  ::mlir::MutableOperandRange inputMutable();
  ::mlir::MutableOperandRange init_valueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range output();
  ::mlir::ArrayAttr dimensions_to_reduceAttr();
  ::mlir::ArrayAttr dimensions_to_reduce();
  ::mlir::SymbolRefAttr reducerAttr();
  ::mlir::SymbolRefAttr reducer();
  size_t N();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimensions_to_reduceAttr(::mlir::ArrayAttr attr);
  void reducerAttr(::mlir::SymbolRefAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::mlir::ValueRange init_value, ::mlir::ArrayAttr dimensions_to_reduce, ::mlir::SymbolRefAttr reducer);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaVariadicReduceOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaVariadicReduceV2Op declarations
//===----------------------------------------------------------------------===//

class XlaVariadicReduceV2OpAdaptor {
public:
  XlaVariadicReduceV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions = {});
  XlaVariadicReduceV2OpAdaptor(XlaVariadicReduceV2Op&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::ValueRange init_values();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr dimensions_to_reduce();
  ::mlir::SymbolRefAttr reducer();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaVariadicReduceV2Op : public ::mlir::Op<XlaVariadicReduceV2Op, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaVariadicReduceV2OpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions_to_reduce"), ::llvm::StringRef("reducer"), ::llvm::StringRef("T"), ::llvm::StringRef("operand_segment_sizes")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier dimensions_to_reduceAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier dimensions_to_reduceAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier reducerAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier reducerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  ::mlir::Identifier operand_segment_sizesAttrName() {
    return getAttributeNameForIndex(3);
  }
  static ::mlir::Identifier operand_segment_sizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaVariadicReduceV2");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::Operation::operand_range init_values();
  ::mlir::MutableOperandRange inputsMutable();
  ::mlir::MutableOperandRange init_valuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range outputs();
  ::mlir::ArrayAttr dimensions_to_reduceAttr();
  ::mlir::ArrayAttr dimensions_to_reduce();
  ::mlir::SymbolRefAttr reducerAttr();
  ::mlir::SymbolRefAttr reducer();
  mlir::OperandElementTypeRange T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void dimensions_to_reduceAttr(::mlir::ArrayAttr attr);
  void reducerAttr(::mlir::SymbolRefAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::ValueRange init_values, ::mlir::ArrayAttr dimensions_to_reduce, ::mlir::SymbolRefAttr reducer);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 4 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaVariadicReduceV2Op)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaVariadicSortOp declarations
//===----------------------------------------------------------------------===//

class XlaVariadicSortOpAdaptor {
public:
  XlaVariadicSortOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlaVariadicSortOpAdaptor(XlaVariadicSortOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange inputs();
  ::mlir::Value dimension();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::SymbolRefAttr comparator();
  ::mlir::BoolAttr is_stable();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlaVariadicSortOp : public ::mlir::Op<XlaVariadicSortOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlaVariadicSortOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("comparator"), ::llvm::StringRef("is_stable"), ::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier comparatorAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier comparatorAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  ::mlir::Identifier is_stableAttrName() {
    return getAttributeNameForIndex(1);
  }
  static ::mlir::Identifier is_stableAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(2);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.XlaVariadicSort");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range inputs();
  ::mlir::Value dimension();
  ::mlir::MutableOperandRange inputsMutable();
  ::mlir::MutableOperandRange dimensionMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range outputs();
  ::mlir::SymbolRefAttr comparatorAttr();
  ::mlir::SymbolRefAttr comparator();
  ::mlir::BoolAttr is_stableAttr();
  bool is_stable();
  mlir::OperandElementTypeRange T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  void comparatorAttr(::mlir::SymbolRefAttr attr);
  void is_stableAttr(::mlir::BoolAttr attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::Value dimension, ::mlir::SymbolRefAttr comparator, ::mlir::BoolAttr is_stable);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::Value dimension, ::mlir::SymbolRefAttr comparator, bool is_stable);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 3 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlaVariadicSortOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Xlog1pyOp declarations
//===----------------------------------------------------------------------===//

class Xlog1pyOpAdaptor {
public:
  Xlog1pyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  Xlog1pyOpAdaptor(Xlog1pyOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class Xlog1pyOp : public ::mlir::Op<Xlog1pyOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::TF::SameOperandsAndResultElementTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Xlog1pyOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Xlog1py");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::Xlog1pyOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlogyOp declarations
//===----------------------------------------------------------------------===//

class XlogyOpAdaptor {
public:
  XlogyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  XlogyOpAdaptor(XlogyOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class XlogyOp : public ::mlir::Op<XlogyOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::OpTrait::TF::SameOperandsAndResultElementTypeResolveRef, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XlogyOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Xlogy");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value y();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange yMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::XlogyOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::YieldOp declarations
//===----------------------------------------------------------------------===//

class YieldOpAdaptor {
public:
  YieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  YieldOpAdaptor(YieldOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::ValueRange operands();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class YieldOp : public ::mlir::Op<YieldOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::ZeroResult, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ReturnLike, ::mlir::OpTrait::IsTerminator, ::mlir::OpTrait::HasParent<CaseRegionOp, IfRegionOp, WhileRegionOp>::Impl> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = YieldOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Yield");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range operands();
  ::mlir::MutableOperandRange operandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::YieldOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ZerosLikeOp declarations
//===----------------------------------------------------------------------===//

class ZerosLikeOpAdaptor {
public:
  ZerosLikeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ZerosLikeOpAdaptor(ZerosLikeOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ZerosLikeOp : public ::mlir::Op<ZerosLikeOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::IsIdempotent, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SameOperandsAndResultType, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ZerosLikeOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.ZerosLike");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::MutableOperandRange xMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value y();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ZerosLikeOp)

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ZetaOp declarations
//===----------------------------------------------------------------------===//

class ZetaOpAdaptor {
public:
  ZetaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs = nullptr, ::mlir::RegionRange regions = {});
  ZetaOpAdaptor(ZetaOp&op);
  ::mlir::ValueRange getOperands();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::ValueRange getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value q();
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::LogicalResult verify(::mlir::Location loc);

private:
  ::mlir::ValueRange odsOperands;
  ::mlir::DictionaryAttr odsAttrs;
  ::mlir::RegionRange odsRegions;
};
class ZetaOp : public ::mlir::Op<ZetaOp, ::mlir::OpTrait::ZeroRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::TensorType>::Impl, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::ResultsBroadcastableShape, ::mlir::DerivedAttributeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ZetaOpAdaptor;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("T")};
  return ::llvm::makeArrayRef(attrNames);
  }
  ::mlir::Identifier TAttrName() {
    return getAttributeNameForIndex(0);
  }
  static ::mlir::Identifier TAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("tf.Zeta");
  }
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value x();
  ::mlir::Value q();
  ::mlir::MutableOperandRange xMutable();
  ::mlir::MutableOperandRange qMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value z();
  ::mlir::Type T();
  static bool isDerivedAttribute(::llvm::StringRef name);
  ::mlir::DictionaryAttr materializeDerivedAttributes();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value x, Value y);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value q);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value q);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verify();
  void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);

private:
  ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }
  static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
  assert(index < 1 && "invalid attribute index");
  return name.getAbstractOperation()->getAttributeNames()[index];
  }
};
} // namespace TF
} // namespace mlir
DECLARE_EXPLICIT_TYPE_ID(::mlir::TF::ZetaOp)


#endif  // GET_OP_CLASSES

